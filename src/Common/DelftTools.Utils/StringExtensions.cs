/*
 * Code from StackOverflow: http://stackoverflow.com/questions/1759154/c-string-parsing-to-variable-types
 * Author: http://stackoverflow.com/users/210809/ckknight
 */

using System;
using System.Globalization;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Threading;

namespace DelftTools.Utils
{
    public static class StringExtensions
    {
        /// <summary>
        /// Replaces the first occurrence of <paramref name="oldValue"/> in <paramref name="text"/> by <paramref name="newValue"/>
        /// </summary>
        /// <returns>The resulting string</returns>
        public static string ReplaceFirst(this string text, string oldValue, string newValue)
        {
            var pos = text.IndexOf(oldValue);

            return pos >= 0
                       ? text.Substring(0, pos) + newValue + text.Substring(pos + oldValue.Length)
                       : text;
        }

        /// <summary>
        /// Parse the <paramref name="target"/> as a <typeparamref name="T"/>. If this cannot be achieved, return the default value of <typeparamref name="T"/>.
        /// </summary>
        /// <typeparam name="T">The type to parse into.</typeparam>
        /// <param name="target">The string to parse.</param>
        /// <returns>The resultant <typeparamref name="T"/> or the default of <typeparamref name="T"/>.</returns>
        /// <example>
        /// <code>
        /// "1234".Parse&ltint&gt;() == 1234;
        /// "a".Parse&ltint&gt;() == 0;
        /// "a".Parse&ltint?&gt;() == null;
        /// "2010-01-01".Parse&lt;DateTime?&gt;() == new DateTime(2010, 1, 1)
        /// "2010-01-01a".Parse&lt;DateTime?&gt;() == null
        /// "127.0.0.1".Parse&lt;System.Net.IPAddress&gt;().Equals(new System.Net.IPAddress(new byte[] { 127, 0, 0, 1 }))
        /// "".Parse&lt;System.Net.IPAddress&gt;() == null
        /// </code>
        /// </example>
        public static T Parse<T>(this string target)
        {
            return ParseHelper<T>.Parse(target);
        }

        /// <summary>
        /// Parse the <paramref name="target"/> as a <typeparamref name="T"/>. If this cannot be achieved, return <paramref name="defaultValue"/>
        /// </summary>
        /// <typeparam name="T">The type to parse into.</typeparam>
        /// <param name="target">The string to parse.</param>
        /// <param name="defaultValue">The value to return if <paramref name="target"/> could not be parsed.</param>
        /// <returns>The resultant <typeparamref name="T"/> or <paramref name="defaultValue"/>.</returns>
        /// <example>
        /// <code>
        /// "1234".Parse&ltint&gt;(-1) == 1234;
        /// "a".Parse&ltint&gt;(-1) == -1;
        /// "2010-01-01".Parse&lt;DateTime?&gt;(new DateTime(1900, 1, 1)) == new DateTime(2010, 1, 1)
        /// "2010-01-01a".Parse&lt;DateTime?&gt;(new DateTime(1900, 1, 1)) == new DateTime(1900, 1, 1)
        /// "127.0.0.1".Parse&lt;System.Net.IPAddress&gt;(new System.Net.IPAddress(new byte[] { 0, 0, 0, 0 })).Equals(new System.Net.IPAddress(new byte[] { 127, 0, 0, 1 }))
        /// "".Parse&lt;System.Net.IPAddress&gt;(new System.Net.IPAddress(new byte[] { 0, 0, 0, 0 })).Equals(new System.Net.IPAddress(new byte[] { 0, 0, 0, 0 }))
        /// </code>
        /// </example>
        public static T Parse<T>(this string target, T defaultValue)
        {
            return ParseHelper<T>.Parse(target, defaultValue);
        }

        private static class ParseHelper<T>
        {
            private static readonly Func<string, T, T, T> _parser;

            static ParseHelper()
            {
                Type type = typeof(T);
                bool isNullable = false;
                if (type.GetGenericArguments().Length > 0 && type.GetGenericTypeDefinition() == typeof(Nullable<>))
                {
                    isNullable = true;
                    type = type.GetGenericArguments()[0];
                }

                ParameterExpression target = Expression.Parameter(typeof(string), "target");
                ParameterExpression defaultValue = Expression.Parameter(typeof(T), "defaultValue");
                ParameterExpression result = Expression.Parameter(typeof(T), "result");
                Type helper = typeof(NullableParseHelper<>);
                if (isNullable)
                {
                    helper = helper.MakeGenericType(typeof(T), type);
                    MethodInfo parseMethod = helper.GetMethod("Parse");
                    _parser = Expression.Lambda<Func<string, T, T, T>>(
                        Expression.Call(parseMethod, target, defaultValue),
                        target, defaultValue, result).Compile();
                }
                else
                {
                    MethodInfo tryParseMethod = (from m in typeof(T).GetMethods()
                                                 where m.Name == "TryParse"
                                                 let ps = m.GetParameters()
                                                 where ps.Count() == 2
                                                    && ps[0].ParameterType == typeof(string)
                                                    && ps[1].ParameterType == typeof(T).MakeByRefType()
                                                 select m).SingleOrDefault();

                    if (tryParseMethod == null)
                    {
                        throw new InvalidOperationException(String.Format("Cannot find method {0}.TryParse(string, out {0})", type.FullName));
                    }
                    _parser = Expression.Lambda<Func<string, T, T, T>>(
                        Expression.Condition(
                            Expression.Call(tryParseMethod, target, result),
                            result,
                            defaultValue),
                        target, defaultValue, result).Compile();
                }
            }

            public static T Parse(string target)
            {
                return _parser.Invoke(target, default(T), default(T));
            }

            public static T Parse(string target, T defaultValue)
            {
                return _parser.Invoke(target, defaultValue, default(T));
            }

            private static class NullableParseHelper<TBase> where TBase : struct
            {
                private static readonly Func<string, TBase?, TBase, TBase?> _parser;

                static NullableParseHelper()
                {
                    MethodInfo tryParseMethod = (from m in typeof(TBase).GetMethods()
                                                 where m.Name == "TryParse"
                                                 let ps = m.GetParameters()
                                                 where ps.Count() == 2
                                                    && ps[0].ParameterType == typeof(string)
                                                    && ps[1].ParameterType == typeof(TBase).MakeByRefType()
                                                 select m).SingleOrDefault();

                    if (tryParseMethod == null)
                    {
                        throw new InvalidOperationException(String.Format("Cannot find method {0}.TryParse(string, out {0})", typeof(TBase).FullName));
                    }
                    ParameterExpression target = Expression.Parameter(typeof(string), "target");
                    ParameterExpression defaultValue = Expression.Parameter(typeof(TBase?), "defaultValue");
                    ParameterExpression result = Expression.Parameter(typeof(TBase), "result");
                    _parser = Expression.Lambda<Func<string, TBase?, TBase, TBase?>>(
                        Expression.Condition(
                            Expression.Call(tryParseMethod, target, result),
                            Expression.ConvertChecked(result, typeof(TBase?)),
                            defaultValue),
                        target, defaultValue, result).Compile();
                }

                public static TBase? Parse(string target, TBase? defaultValue)
                {
                    return _parser.Invoke(target, defaultValue, default(TBase));
                }
            }
        }

        public static T Parse<T>(this string target, CultureInfo culture)
        {
            var culture1 = Thread.CurrentThread.CurrentCulture;
            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;
            var result= ParseHelper<T>.Parse(target);
            Thread.CurrentThread.CurrentCulture = culture1;
            return result;
        }
    }
}