<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.dotCover.Interop.WinApi</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression">
            <summary>
            <see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER"/> compression values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_RGB">
            <summary>
            An uncompressed format. (<see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER"/> version 5)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_RLE8">
            <summary>
            A run-length encoded (RLE) format for bitmaps with 8 bpp. The compression format is a 2-byte format consisting of a count byte followed by a byte containing a color index. For more information, see Bitmap Compression.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_RLE4">
            <summary>
            An RLE format for bitmaps with 4 bpp. The compression format is a 2-byte format consisting of a count byte followed by two word-length color indexes. For more information, see Bitmap Compression.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_BITFIELDS">
            <summary>
            Specifies that the bitmap is not compressed and that the color table consists of three DWORD color masks that specify the red, green, and blue components, respectively, of each pixel. This is valid when used with 16- and 32-bpp bitmaps. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_JPEG">
            <summary>
            Windows 98/Me, Windows 2000/XP: Indicates that the image is a JPEG image. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression.BI_PNG">
            <summary>
            Windows 98/Me, Windows 2000/XP: Indicates that the image is a PNG image. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.HookCode">
            <summary>
            Hook codes for callback functions of <see cref="M:JetBrains.UI.Interop.Win32Declarations.SetWindowsHookEx(JetBrains.UI.Interop.HookType,JetBrains.UI.Interop.Win32Declarations.HookProc,System.IntPtr,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.HookCode.HC_ACTION">
            <summary>
            Mouse hook: The wParam and lParam parameters contain information about a mouse message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.HookCode.HC_NOREMOVE">
            <summary>
            Mouse hook: The wParam and lParam parameters contain information about a mouse message, and the mouse message has not been removed from the message queue. (An application called the PeekMessage function, specifying the PM_NOREMOVE flag.)
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes">
            <summary>
            The type of memory allocation. This parameter must contain one of the following values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_COMMIT">
            <summary>
            Allocates physical storage in memory or in the paging file on disk for the specified reserved memory pages. The function initializes the memory to zero.
            To reserve and commit pages in one step, call VirtualAlloc with MEM_COMMIT | MEM_RESERVE.
            The function fails if you attempt to commit a page that has not been reserved. The resulting error code is ERROR_INVALID_ADDRESS.
            An attempt to commit a page that is already committed does not cause the function to fail. This means that you can commit pages without first determining the current commitment state of each page.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_RESERVE">
            <summary>
            Reserves a range of the process's virtual address space without allocating any actual physical storage in memory or in the paging file on disk.
            You can commit reserved pages in subsequent calls to the VirtualAlloc function. To reserve and commit pages in one step, call VirtualAlloc with MEM_COMMIT | MEM_RESERVE.
            Other memory allocation functions, such as malloc and LocalAlloc, cannot use a reserved range of memory until it is released.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_RESET">
            <summary>
            Indicates that data in the memory range specified by lpAddress and dwSize is no longer of interest. The pages should not be read from or written to the paging file. However, the memory block will be used again later, so it should not be decommitted. This value cannot be used with any other value.
            Using this value does not guarantee that the range operated on with MEM_RESET will contain zeroes. If you want the range to contain zeroes, decommit the memory and then recommit it.
            When you specify MEM_RESET, the VirtualAlloc function ignores the value of flProtect. However, you must still set flProtect to a valid protection value, such as PAGE_NOACCESS.
            VirtualAlloc returns an error if you use MEM_RESET and the range of memory is mapped to a file. A shared view is only acceptable if it is mapped to a paging file.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_FREE">
            <summary>
            Indicates free pages not accessible to the calling process and available to be allocated. For free pages, the information in the AllocationBase, AllocationProtect, Protect, and Type members is undefined.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_LARGE_PAGES">
            <summary>
            Allocates memory using large page support.
            The size and alignment must be a multiple of the large-page minimum. To obtain this value, use the GetLargePageMinimum function.
            Windows XP/2000:   This flag is not supported.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_PHYSICAL">
            <summary>
            Reserves an address range that can be used to map Address Windowing Extensions (AWE) pages. 
            This value must be used with MEM_RESERVE and no other values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_TOP_DOWN">
            <summary>
            Allocates memory at the highest possible address.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_WRITE_WATCH">
            <summary>
            Causes the system to track pages that are written to in the allocated region. If you specify this value, you must also specify MEM_RESERVE.
            To retrieve the addresses of the pages that have been written to since the region was allocated or the write-tracking state was reset, call the GetWriteWatch function. To reset the write-tracking state, call GetWriteWatch or ResetWriteWatch. The write-tracking feature remains enabled for the memory region until the region is freed.
            Windows 2000:   This flag is not supported.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryPageTypes">
            <summary>
            The type of pages in the region. The following types are defined. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryPageTypes.MEM_IMAGE">
            <summary>
            Indicates that the memory pages within the region are mapped into the view of an image section.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryPageTypes.MEM_MAPPED">
            <summary>
            Indicates that the memory pages within the region are mapped into the view of a section.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryPageTypes.MEM_PRIVATE">
            <summary>
            Indicates that the memory pages within the region are private (that is, not shared by other processes).
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants">
            <summary>
            The following are the memory-protection options; you must specify one of the following values when allocating or protecting a page in memory. Protection attributes cannot be assigned to a portion of a page; they can only be assigned to a whole page.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_EXECUTE">
            <summary>
            Enables execute access to the committed region of pages. An attempt to read from or write to the committed region results in an access violation. 
            This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_EXECUTE_READ">
            <summary>
            Enables execute or read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. 
            Windows Server 2003 and Windows XP/2000:  This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_EXECUTE_READWRITE">
            <summary>
            Enables execute, read-only, or read/write access to the committed region of pages. 
            Windows Server 2003 and Windows XP/2000:  This attribute is not supported by the CreateFileMapping function until Windows XP with SP2 and Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_EXECUTE_WRITECOPY">
            <summary>
            Enables execute, read-only, or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_EXECUTE_READWRITE, and the change is written to the new page. 
            This flag is not supported by the VirtualAlloc or VirtualAllocEx functions. 
            Windows Vista, Windows Server 2003, and Windows XP/2000:  This attribute is not supported by the CreateFileMapping function until Windows Vista with SP1 and Windows Server 2008.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_NOACCESS">
            <summary>
            Disables all access to the committed region of pages. An attempt to read from, write to, or execute the committed region results in an access violation. 
            This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_READONLY">
            <summary>
            Enables read-only access to the committed region of pages. An attempt to write to the committed region results in an access violation. If Data Execution Prevention is enabled, an attempt to execute code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_READWRITE">
            <summary>
            Enables read-only or read/write access to the committed region of pages. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_WRITECOPY">
            <summary>
            Enables read-only or copy-on-write access to a mapped view of a file mapping object. An attempt to write to a committed copy-on-write page results in a private copy of the page being made for the process. The private page is marked as PAGE_READWRITE, and the change is written to the new page. If Data Execution Prevention is enabled, attempting to execute code in the committed region results in an access violation.
            This flag is not supported by the VirtualAlloc or VirtualAllocEx functions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_GUARD">
            <summary>
            Pages in the region become guard pages. Any attempt to access a guard page causes the system to raise a STATUS_GUARD_PAGE_VIOLATION exception and turn off the guard page status. Guard pages thus act as a one-time access alarm. For more information, see Creating Guard Pages. 
            When an access attempt leads the system to turn off guard page status, the underlying page protection takes over.
            If a guard page exception occurs during a system service, the service typically returns a failure status indicator.
            This value cannot be used with PAGE_NOACCESS.
            This flag is not supported by the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_NOCACHE">
            <summary>
            Sets all pages to be non-cachable. Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped with SEC_NOCACHE can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
            The PAGE_NOCACHE flag cannot be used with the PAGE_GUARD, PAGE_NOACCESS, or PAGE_WRITECOMBINE flags.
            The PAGE_NOCACHE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable non-cached memory access for shared memory, specify the SEC_NOCACHE flag when calling the CreateFileMapping function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants.PAGE_WRITECOMBINE">
            <summary>
            Sets all pages to be write-combined. 
            Applications should not use this attribute except when explicitly required for a device. Using the interlocked functions with memory that is mapped as write-combined can result in an EXCEPTION_ILLEGAL_INSTRUCTION exception.
            The PAGE_WRITECOMBINE flag cannot be specified with the PAGE_NOACCESS, PAGE_GUARD, and PAGE_NOCACHE flags. 
            The PAGE_WRITECOMBINE flag can be used only when allocating private memory with the VirtualAlloc, VirtualAllocEx, or VirtualAllocExNuma functions. To enable write-combined memory access for shared memory, specify the SEC_WRITECOMBINE flag when calling the CreateFileMapping function.
            Windows Server 2003 and Windows XP/2000:  This flag is not supported until Windows Server 2003 with SP1.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.UxThemeClasses">
            <summary>
            Classes for <see cref="T:JetBrains.Interop.WinApi.UxThemeDll"/> functions like <see cref="M:JetBrains.Interop.WinApi.UxThemeDll.OpenThemeData(System.Void*,System.String)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.UxThemeParts">
            <summary>
            Parts for <see cref="T:JetBrains.Interop.WinApi.UxThemeDll"/> functions like <see cref="M:JetBrains.Interop.WinApi.UxThemeDll.DrawThemeBackground(System.Void*,System.Void*,System.Int32,System.Int32,JetBrains.Interop.WinApi.RECT*,JetBrains.Interop.WinApi.RECT*)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.IpHlpApiDll">
            <summary>
            User32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PsApiDll">
            <summary>
            Kernel32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.PsApiDll.EnumProcessModules(System.Void*,System.Void**,System.UInt32,System.UInt32*)">
            <summary>
            Retrieves a handle for each module in the specified process.
            To control whether a 64-bit application enumerates 32-bit modules, 64-bit modules, or both types of modules, use the EnumProcessModulesEx function.
            </summary>
            <param name="hProcess">A handle to the process.</param>
            <param name="lphModule">An array that receives the list of module handles.</param>
            <param name="cb">The size of the lphModule array, in bytes.</param>
            <param name="lpcbNeeded">The number of bytes required to store all module handles in the lphModule array.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
            <remarks>
            […]
            It is a good idea to specify a large array of HMODULE values, because it is hard to predict how many modules there will be in the process at the time you call EnumProcessModules. To determine if the lphModule array is too small to hold all module handles for the process, compare the value returned in lpcbNeeded with the value specified in cb. If lpcbNeeded is greater than cb, increase the size of the array and call EnumProcessModules again.
            To determine how many modules were enumerated by the call to EnumProcessModules, divide the resulting value in the lpcbNeeded parameter by sizeof(HMODULE).
            […]
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER">
            <summary>
            The BITMAPINFOHEADER structure contains information about the dimensions and color format of a DIB. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biSize">
            <summary>
            Specifies the number of bytes required by the structure. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biWidth">
            <summary>
            Specifies the width of the bitmap, in pixels. 
            Windows 98/Me, Windows 2000/XP: If biCompression is BI_JPEG or BI_PNG, the biWidth member specifies the width of the decompressed JPEG or PNG image file, respectively.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biHeight">
            <summary>
            Specifies the height of the bitmap, in pixels. If biHeight is positive, the bitmap is a bottom-up DIB and its origin is the lower-left corner. If biHeight is negative, the bitmap is a top-down DIB and its origin is the upper-left corner. 
            If biHeight is negative, indicating a top-down DIB, biCompression must be either BI_RGB or BI_BITFIELDS. Top-down DIBs cannot be compressed. 
            Windows 98/Me, Windows 2000/XP: If biCompression is BI_JPEG or BI_PNG, the biHeight member specifies the height of the decompressed JPEG or PNG image file, respectively. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biPlanes">
            <summary>
            Specifies the number of planes for the target device. This value must be set to 1. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biBitCount">
            <summary>
            Specifies the number of bits-per-pixel. The biBitCount member of the BITMAPINFOHEADER structure determines the number of bits that define each pixel and the maximum number of colors in the bitmap. This member must be one of the following values. 
            Value Meaning 
            0 Windows 98/Me, Windows 2000/XP: The number of bits-per-pixel is specified or is implied by the JPEG or PNG format.  
            1 The bitmap is monochrome, and the bmiColors member of BITMAPINFO contains two entries. Each bit in the bitmap array represents a pixel. If the bit is clear, the pixel is displayed with the color of the first entry in the bmiColors table; if the bit is set, the pixel has the color of the second entry in the table. 
            4 The bitmap has a maximum of 16 colors, and the bmiColors member of BITMAPINFO contains up to 16 entries. Each pixel in the bitmap is represented by a 4-bit index into the color table. For example, if the first byte in the bitmap is 0x1F, the byte represents two pixels. The first pixel contains the color in the second table entry, and the second pixel contains the color in the sixteenth table entry. 
            8 The bitmap has a maximum of 256 colors, and the bmiColors member of BITMAPINFO contains up to 256 entries. In this case, each byte in the array represents a single pixel. 
            16 The bitmap has a maximum of 2^16 colors. If the biCompression member of the BITMAPINFOHEADER is BI_RGB, the bmiColors member of BITMAPINFO is NULL. Each WORD in the bitmap array represents a single pixel. The relative intensities of red, green, and blue are represented with five bits for each color component. The value for blue is in the least significant five bits, followed by five bits each for green and red. The most significant bit is not used. The bmiColors color table is used for optimizing colors used on palette-based devices, and must contain the number of entries specified by the biClrUsed member of the BITMAPINFOHEADER. 
            If the biCompression member of the BITMAPINFOHEADER is BI_BITFIELDS, the bmiColors member contains three DWORD color masks that specify the red, green, and blue components, respectively, of each pixel. Each WORD in the bitmap array represents a single pixel.
            Windows NT/Windows 2000/XP: When the biCompression member is BI_BITFIELDS, bits set in each DWORD mask must be contiguous and should not overlap the bits of another mask. All the bits in the pixel do not have to be used. 
            Windows 95/98/Me: When the biCompression member is BI_BITFIELDS, the system supports only the following 16bpp color masks: A 5-5-5 16-bit image, where the blue mask is 0x001F, the green mask is 0x03E0, and the red mask is 0x7C00; and a 5-6-5 16-bit image, where the blue mask is 0x001F, the green mask is 0x07E0, and the red mask is 0xF800.
            24 The bitmap has a maximum of 2^24 colors, and the bmiColors member of BITMAPINFO is NULL. Each 3-byte triplet in the bitmap array represents the relative intensities of blue, green, and red, respectively, for a pixel. The bmiColors color table is used for optimizing colors used on palette-based devices, and must contain the number of entries specified by the biClrUsed member of the BITMAPINFOHEADER.  
            32 The bitmap has a maximum of 2^32 colors. If the biCompression member of the BITMAPINFOHEADER is BI_RGB, the bmiColors member of BITMAPINFO is NULL. Each DWORD in the bitmap array represents the relative intensities of blue, green, and red, respectively, for a pixel. The high byte in each DWORD is not used. The bmiColors color table is used for optimizing colors used on palette-based devices, and must contain the number of entries specified by the biClrUsed member of the BITMAPINFOHEADER. 
            If the biCompression member of the BITMAPINFOHEADER is BI_BITFIELDS, the bmiColors member contains three DWORD color masks that specify the red, green, and blue components, respectively, of each pixel. Each DWORD in the bitmap array represents a single pixel.
            Windows NT/ 2000: When the biCompression member is BI_BITFIELDS, bits set in each DWORD mask must be contiguous and should not overlap the bits of another mask. All the bits in the pixel do not need to be used.
            Windows 95/98/Me: When the biCompression member is BI_BITFIELDS, the system supports only the following 32-bpp color mask: The blue mask is 0x000000FF, the green mask is 0x0000FF00, and the red mask is 0x00FF0000. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biCompression">
            <summary>
            Use <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.BiCompression"/>.
            Specifies the type of compression for a compressed bottom-up bitmap (top-down DIBs cannot be compressed). This member can be one of the following values. 
            Value Description 
            BI_RGB An uncompressed format. 
            BI_RLE8 A run-length encoded (RLE) format for bitmaps with 8 bpp. The compression format is a 2-byte format consisting of a count byte followed by a byte containing a color index. For more information, see Bitmap Compression.  
            BI_RLE4 An RLE format for bitmaps with 4 bpp. The compression format is a 2-byte format consisting of a count byte followed by two word-length color indexes. For more information, see Bitmap Compression. 
            BI_BITFIELDS Specifies that the bitmap is not compressed and that the color table consists of three DWORD color masks that specify the red, green, and blue components, respectively, of each pixel. This is valid when used with 16- and 32-bpp bitmaps. 
            BI_JPEG Windows 98/Me, Windows 2000/XP: Indicates that the image is a JPEG image. 
            BI_PNG Windows 98/Me, Windows 2000/XP: Indicates that the image is a PNG image. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biSizeImage">
            <summary>
            Specifies the size, in bytes, of the image. This may be set to zero for BI_RGB bitmaps. 
            Windows 98/Me, Windows 2000/XP: If biCompression is BI_JPEG or BI_PNG, biSizeImage indicates the size of the JPEG or PNG image buffer, respectively. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biXPelsPerMeter">
            <summary>
            Specifies the horizontal resolution, in pixels-per-meter, of the target device for the bitmap. An application can use this value to select a bitmap from a resource group that best matches the characteristics of the current device. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biYPelsPerMeter">
            <summary>
            Specifies the vertical resolution, in pixels-per-meter, of the target device for the bitmap. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biClrUsed">
            <summary>
            Specifies the number of color indexes in the color table that are actually used by the bitmap. If this value is zero, the bitmap uses the maximum number of colors corresponding to the value of the biBitCount member for the compression mode specified by biCompression. 
            If biClrUsed is nonzero and the biBitCount member is less than 16, the biClrUsed member specifies the actual number of colors the graphics engine or device driver accesses. If biBitCount is 16 or greater, the biClrUsed member specifies the size of the color table used to optimize performance of the system color palettes. If biBitCount equals 16 or 32, the optimal color palette starts immediately following the three DWORD masks. 
            When the bitmap array immediately follows the BITMAPINFO structure, it is a packed bitmap. Packed bitmaps are referenced by a single pointer. Packed bitmaps require that the biClrUsed member must be either zero or the actual size of the color table. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER.biClrImportant">
            <summary>
            Specifies the number of color indexes that are required for displaying the bitmap. If this value is zero, all colors are required. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO">
            <summary>
            The BITMAPINFO structure defines the dimensions and color information for a DIB. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO.bmiHeader">
            <summary>
            Specifies a <see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER"/> structure that contains information about the dimensions of color format.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO.bmiColors">
            <summary>
            <c>Null</c>, unless you're using a palette.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION">
            <summary>
            The BLENDFUNCTION structure controls blending by specifying the blending functions for source and destination bitmaps.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.BlendOp">
            <summary>
            Specifies the source blend operation. Currently, the only source and destination blend operation that has been defined is <see cref="F:JetBrains.UI.Interop.Win32Declarations.AC_SRC_OVER"/>. For details, see the following Remarks section. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.BlendFlags">
            <summary>
            Must be zero. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.SourceConstantAlpha">
            <summary>
            Specifies an alpha transparency value to be used on the entire source bitmap. The SourceConstantAlpha value is combined with any per-pixel alpha values in the source bitmap. If you set SourceConstantAlpha to 0, it is assumed that your image is transparent. Set the SourceConstantAlpha value to 255 (opaque) when you only want to use per-pixel alpha values. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.AlphaFormat">
            <summary>
            This member controls the way the source and destination bitmaps are interpreted. AlphaFormat has the following value.
            <see cref="F:JetBrains.UI.Interop.Win32Declarations.AC_SRC_ALPHA"/> -&gt; This flag is set when the bitmap has an Alpha channel (that is, per-pixel alpha). Note that the APIs use premultiplied alpha, which means that the red, green and blue channel values in the bitmap must be premultiplied with the alpha channel value. For example, if the alpha channel value is x, the red, green and blue channels must be multiplied by x and divided by 0xff prior to the call. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.GetPerPixelBlender(System.Byte)">
            <summary>
            Gets such a structure that supports per-pixel blending and applies an additional constant alpha to the whole bitmap (set <c>255</c> for no constant alpha, just per-pixel).
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.GetPerPixelBlender">
            <summary>
            Gets a per-pixel blender without uniform transparency.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.GetUniformBlender(System.Byte)">
            <summary>
            Gets such a structure that supports uniform transparency only.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION.GetUniformBlender">
            <summary>
            Gets an opaque blender that ignores per-pixel alpha and has no uniform transparency.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Advapi32Dll">
            <summary>
            User32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.AccessRights">
            <remarks>
            <code>
             3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
             1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
            +---------------+---------------+-------------------------------+
            |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
            |R|W|E|A|     |S|               |                               |
            +-+-------------+---------------+-------------------------------+
            </code>
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.CombineRgnStyles">
            <summary>
            Specifies the operation to be performed over the regions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_AND">
            <summary>
            The new clipping region combines the overlapping areas of the current clipping region and the region identified by hrgn. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_OR">
            <summary>
            The new clipping region is a copy of the region identified by hrgn. This is identical to SelectClipRgn. If the region identified by hrgn is NULL, the new clipping region is the default clipping region (the default clipping region is a null region). 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_XOR">
            <summary>
            The new clipping region combines the areas of the current clipping region with those areas excluded from the region identified by hrgn. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_DIFF">
            <summary>
            The new clipping region combines the current clipping region and the region identified by hrgn. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_COPY">
            <summary>
            The new clipping region combines the current clipping region and the region identified by hrgn but excludes any overlapping areas. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_MIN">
            <summary>
            Same as <see cref="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_AND"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_MAX">
            <summary>
            Same as <see cref="F:JetBrains.Interop.WinApi.CombineRgnStyles.RGN_COPY"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.CorSymSearchPolicyAttributes">
            <summary>
            Specifies the policy to be used when doing a search for a symbol reader.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CorSymSearchPolicyAttributes.AllowRegistryAccess">
            <summary>
            Queries the registry for symbol search paths.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CorSymSearchPolicyAttributes.AllowSymbolServerAccess">
            <summary>
            Accesses a symbol server.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CorSymSearchPolicyAttributes.AllowOriginalPathAccess">
            <summary>
            Searches the path specified in the Debug directory.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CorSymSearchPolicyAttributes.AllowReferencePathAccess">
            <summary>
            Searches for the PDB in the place where the .exe file is.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.OBJID">
            <summary>
            Reserved IDs for system objects. See <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_GETOBJECT"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PDTIMER_FLAGS">
            <summary>
            // Time Actions (dwTimerAction)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PDTIMER_FLAGS.PDTIMER_RESET">
            <summary>
            // Reset the timer so the progress will be calculated from now until the first ::SetProgress() is called so those this time will correspond to the values passed to ::SetProgress().  Only do this before ::SetProgress() is called.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PDTIMER_FLAGS.PDTIMER_PAUSE">
            <summary>
            Progress has been suspended.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PDTIMER_FLAGS.PDTIMER_RESUME">
            <summary>
            Progress has resumed.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PROGDLG_FLAGS">
            <summary>
            // Flags for IProgressDialog::StartProgressDialog() (dwFlags)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_NORMAL">
            <summary>
            default normal progress dlg behavior
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_MODAL">
            <summary>
            the dialog is modal to its hwndParent (default is modeless)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_AUTOTIME">
            <summary>
            automatically updates the "Line3" text with the "time remaining" (you cant call SetLine3 if you passs this!)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_NOTIME">
            <summary>
            we dont show the "time remaining" if this is set. We need this if dwTotal &lt; dwCompleted for sparse files
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_NOMINIMIZE">
            <summary>
            Do not have a minimize button in the caption bar.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_NOPROGRESSBAR">
            <summary>
            Don't display the progress bar
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_MARQUEEPROGRESS">
            <summary>
            Use marquee progress (comctl32 v6 required)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PROGDLG_FLAGS.PROGDLG_NOCANCEL">
            <summary>
            No cancel button (operation cannot be canceled) (use sparingly)  
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.DialogBoxCommandId">
            <summary>
            Standard command IDs for the dialog boxes.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.DialogCodes">
            <summary>
            Dialog Codes.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MessageBoxFlags">
            <summary>
            Flags for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.MessageBoxW(System.Void*,System.String,System.String,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.OleCmdErr">
            <summary>
             OLE CMD Errors from <c>DocObj.h</c>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.SystemMetricsCodes">
            <summary>
            Codes for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetSystemMetrics(System.Int32)"/> function.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.WaitResult">
            <summary>
            Result flags for the wait functions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.WaitResult.WAIT_ABANDONED">
            <summary>
             The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.
            If the mutex was protecting persistent state information, you should check it for consistency.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.WaitResult.WAIT_OBJECT_0">
            <summary>
            The state of the specified object is signaled.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.WaitResult.WAIT_TIMEOUT">
            <summary>
            The time-out interval elapsed, and the object's state is nonsignaled.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Interop.WinApi.Interfaces.IProgressDialog" -->
        <member name="T:JetBrains.Interop.WinApi.Declarations.Interfaces.IServiceProvider">
            <summary>
            <para>The IServiceProvider interface is a generic access mechanism to locate a GUID-identified service that is provided through a control or any other object that the service can communicate with. For example, an embedded object (such as an OLE control) typically communicates only with its associated client site object in the container through the IOleClientSite interface that is supplied by using IOleObject::SetClientSite. The embedded object must ask the client site for some other service that the container supports when that service might not be implemented in the client site.</para>
            <para>The client site must provide a means by which the control that is managed by the site can access the service when necessary. For example, the IOleInPlaceSite::GetWindowContext function can be used by an in-place object or control to access interface pointers for the document object that contains the site and the frame object that contains the document. Because these interface pointers exist on separate objects, the control cannot call the site's QueryInterface to obtain those pointers. Instead, use the IServiceProvider interface. </para>
            <para>The IServiceProvider interface has only one member, QueryService, through which a caller specifies the service ID (SID, a GUID), the IID of the interface to return, and the address of the caller's interface pointer variable. </para>
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Interfaces.IServiceProvider.QueryService(System.Guid*,System.Guid*)">
            <summary>
            Acts as the factory method for any services exposed through an implementation of IServiceProvider.
            </summary>
            <param name="guidService">[in] The unique identifier of the service (an SID). </param>
            <param name="riid">[in] The unique identifier of the interface that the caller wants to receive for the service. </param>
            <returns>[out] The address of the caller-allocated variable to receive the interface pointer of the service on successful return from this function. The caller becomes responsible for calling Release through this interface pointer when the service is no longer required.</returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Macros">
            <summary>
            Hosts the scattered WinAPI macros, in the form of functions.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Macros.GET_X_LPARAM(System.IntPtr)">
            <summary>
            Gets a signed x-coordinate packed into an LPARAM, usually in Windows messgaes.
            To create a point from an LPARAM, use casting thru the <see cref="T:JetBrains.Interop.WinApi.POINT"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Macros.GET_Y_LPARAM(System.IntPtr)">
            <summary>
            Gets a signed y-coordinate packed into an LPARAM, usually in Windows messgaes.
            To create a point from an LPARAM, use casting thru the <see cref="T:JetBrains.Interop.WinApi.POINT"/> class.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Macros.MAKEDWORD(System.UInt16,System.UInt16)">
            <summary>
            In WinAPI, this is called <c>MAKELONG</c> (C's <c>long</c> is of the same size as a DWORD, whilst in C# it's a QWORD).
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MsImg32Dll">
            <summary>
            MsImg32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.MsImg32Dll.AlphaBlend(System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION)">
            <summary>
            The AlphaBlend function displays bitmaps that have transparent or semitransparent pixels.
            </summary>
            <param name="hdcDest">
            [in] Handle to the destination device context. </param>
            <param name="nXOriginDest">
            [in] Specifies the x-coordinate, in logical units, of the upper-left corner of the destination rectangle. </param>
            <param name="nYOriginDest">
            [in] Specifies the y-coordinate, in logical units, of the upper-left corner of the destination rectangle. </param>
            <param name="nWidthDest">
            [in] Specifies the width, in logical units, of the destination rectangle. </param>
            <param name="nHeightDest">
            [in] Specifies the height, in logical units, of the destination rectangle. </param>
            <param name="hdcSrc">
            [in] Handle to the source device context. </param>
            <param name="nXOriginSrc">
            [in] Specifies the x-coordinate, in logical units, of the upper-left corner of the source rectangle. </param>
            <param name="nYOriginSrc">
            [in] Specifies the y-coordinate, in logical units, of the upper-left corner of the source rectangle. </param>
            <param name="nWidthSrc">
            [in] Specifies the width, in logical units, of the source rectangle. </param>
            <param name="nHeightSrc">
            [in] Specifies the height, in logical units, of the source rectangle. </param>
            <param name="blendFunction">
            [in] Specifies the alpha-blending function for source and destination bitmaps, a global alpha value to be applied to the entire source bitmap, and format information for the source bitmap. The source and destination blend functions are currently limited to AC_SRC_OVER. See the <see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION"/> and EMRALPHABLEND structures. </param>
            <returns>If the function succeeds, the return value is TRUE. If the function fails, the return value is FALSE.</returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Ole32Dll">
            <summary>
            Ole32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.OleAut32Dll">
            <summary>
            OleAut32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.OleAut32Dll.VariantClear(System.Void*)">
             <summary>
             Clears a variant.
             </summary>
             <param name="pvarg">Pointer to the <c>VARIANTARG</c> to clear.</param>
             <returns>The return value obtained from the returned HRESULT is one of the following.</returns>
             <remarks>
             Use this function to clear variables of type VARIANTARG (or VARIANT) before the memory containing the VARIANTARG is freed (as when a local variable goes out of scope). 
            
             The function clears a VARIANTARG by setting the vt field to VT_EMPTY. The current contents of the VARIANTARG are released first. If the vtfield is VT_BSTR, the string is freed. If the vtfield is VT_DISPATCH, the object is released. If the vt field has the VT_ARRAY bit set, the array is freed. 
            
             If the variant to be cleared is a COM object that is passed by reference, the vtfield of the pvargparameter is VT_DISPATCH | VT_BYREF or VT_UNKNOWN | VT_BYREF. In this case, VariantClear does not release the object. Because the variant being cleared is a pointer to a reference to an object, VariantClear has no way to determine if it is necessary to release the object. It is therefore the responsibility of the caller to release the object or not, as appropriate. 
            
             In certain cases, it may be preferable to clear a variant in code without calling VariantClear. For example, you can change the type of a VT_I4 variant to another type without calling this function. Safearrays of BSTR will have SysFreeString called on each element not VariantClear. However, you must call VariantClear if a VT_type is received but cannot be handled. Safearrays of variant will also have VariantClear called on each member. Using VariantClear in these cases ensures that code will continue to work if Automation adds new variant types in the future. 
            
             Do not use VariantClear on unitialized variants; use VariantInit to initialize a new VARIANTARG or VARIANT. 
            
             Variants containing arrays with outstanding references cannot be cleared. Attempts to do so will return an HRESULT containing DISP_E_ARRAYISLOCKED. 
             </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.OleAut32Dll.VariantInit(System.Void*)">
            <summary>
            Initializes a variant. 
            </summary>
            <param name="pvarg">Pointer to the VARIANTARG that will be initialized.</param>
            <remarks>The VariantInit function initializes the VARIANTARG by setting the vt field to VT_EMPTY. Unlike VariantClear, this function does not interpret the current contents of the VARIANTARG. Use VariantInit to initialize new local variables of type VARIANTARG (or VARIANT). </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.SHFolderDll.SHGetFolderPathW(System.Void*,System.Int32,System.Void*,System.UInt32,System.Text.StringBuilder)">
            <param name="hwndOwner"></param>
            <param name="nFolder"><see cref="T:JetBrains.Interop.WinApi.CSIDL"/></param>
            <param name="hToken"></param>
            <param name="dwFlags"><see cref="T:JetBrains.Interop.WinApi.SHGFP_TYPE"/></param>
            <param name="lpszPath"></param>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO">
            <summary>
            The CURSORINFO structure contains global cursor information.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO.cbSize">
            <summary>
            Specifies the size, in bytes, of the structure. The caller must set this to <c>sizeof(CURSORINFO)</c>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO.flags">
            <summary>
            Specifies the cursor state. This parameter can be one of the following values. 
            • 0 — The cursor is hidden.
            • CURSOR_SHOWING — The cursor is showing.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO.hCursor">
            <summary>
            Handle to the cursor. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO.ptScreenPos">
            <summary>
            A <see cref="T:JetBrains.Interop.WinApi.POINT"/> structure that receives the screen coordinates of the cursor. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.CWPRETSTRUCT">
            <summary>
            The CWPRETSTRUCT structure defines the message parameters passed to a WH_CALLWNDPROCRET hook procedure, CallWndRetProc.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPRETSTRUCT.lResult">
            <summary>
            Specifies the return value of the window procedure that processed the message specified by the message value. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPRETSTRUCT.lParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the message value. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPRETSTRUCT.wParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the message value. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPRETSTRUCT.message">
            <summary>
            Specifies the message. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPRETSTRUCT.hwnd">
            <summary>
            Handle to the window that processed the message specified by the message value.   
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.CWPSTRUCT">
            <summary>
            The CWPSTRUCT structure defines the message parameters passed to a WH_CALLWNDPROC hook procedure, CallWndProc. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPSTRUCT.lParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the message value. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPSTRUCT.wParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the message value. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPSTRUCT.message">
            <summary>
            Specifies the message. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.CWPSTRUCT.hwnd">
            <summary>
            Handle to the window to receive the message.   
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.GUITHREADINFO">
            <summary>
            The GUITHREADINFO structure contains information about a graphical user interface (GUI) thread.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.cbSize">
            <summary>
            Specifies the size of this structure, in bytes. The caller must set this to sizeof(GUITHREADINFO). 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.flags">
            <summary>
            Specifies the thread state.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndActive">
            <summary>
            Handle to the active window within the thread. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndFocus">
            <summary>
            Handle to the window that has the keyboard focus. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndCapture">
            <summary>
            Handle to the window that has captured the mouse. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndMenuOwner">
            <summary>
            Handle to the window that owns any active menus. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndMoveSize">
            <summary>
            Handle to the window in a move or size loop. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.hwndCaret">
            <summary>
            Handle to the window that is displaying the caret. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GUITHREADINFO.rcCaret">
            <summary>
            A <c>RECT</c> structure that describes the caret's bounding rectangle, in client coordinates, relative to the window specified by the hwndCaret member. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.BaseAddress">
            <summary>
            A pointer to the base address of the region of pages.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.AllocationBase">
            <summary>
            A pointer to the base address of a range of pages allocated by the VirtualAlloc function. The page pointed to by the BaseAddress member is contained within this allocation range.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.AllocationProtect">
            <summary>
            The memory protection option when the region was initially allocated. This member can be one of the memory protection constants or 0 if the caller does not have access.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.RegionSize">
            <summary>
            The size of the region beginning at the base address in which all pages have identical attributes, in bytes.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.State">
            <summary>
            The state of the pages in the region. This member can be one of the following values: <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_COMMIT"/>, <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_RESERVE"/>, <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes.MEM_FREE"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.Protect">
            <summary>
            The access protection of the pages in the region. This member is one of the values listed for the AllocationProtect member.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION.Type">
            <summary>
            The type of pages in the region. See <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryPageTypes"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT">
            <summary>
            The MOUSEHOOKSTRUCT structure contains information about a mouse event passed to a WH_MOUSE hook procedure, MouseProc. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT.pt">
            <summary>
            Specifies a POINT structure that contains the x- and y-coordinates of the cursor, in screen coordinates. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT.hwnd">
            <summary>
            Handle to the window that will receive the mouse message corresponding to the mouse event. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT.wHitTestCode">
            <summary>
            Specifies the hit-test value. For a list of hit-test values, see the description of the WM_NCHITTEST message. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MOUSEHOOKSTRUCT.dwExtraInfo">
            <summary>
            Specifies extra information associated with the message. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MSG">
            <summary>
            The MSG structure contains message information from a thread's message queue. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.hwnd">
            <summary>
            Handle to the window whose window procedure receives the message. hwnd is NULL when the message is a thread message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.message">
            <summary>
            Specifies the message identifier. Applications can only use the low word; the high word is reserved by the system. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.wParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the value of the message member. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.lParam">
            <summary>
            Specifies additional information about the message. The exact meaning depends on the value of the message member.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.time">
            <summary>
            Specifies the time at which the message was posted. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSG.pt">
            <summary>
            Specifies the cursor position, in screen coordinates, when the message was posted. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT">
            <summary>
            The MSLLHOOKSTRUCT structure contains information about a low-level keyboard input event. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT.pt">
            <summary>
            Specifies a POINT structure that contains the x- and y-coordinates of the cursor, in screen coordinates. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT.mouseData">
            <summary>
            <para>If the message is WM_MOUSEWHEEL, the high-order word of this member is the wheel delta. The low-order word is reserved. A positive value indicates that the wheel was rotated forward, away from the user; a negative value indicates that the wheel was rotated backward, toward the user. One wheel click is defined as WHEEL_DELTA, which is 120. </para>
            <para>If the message is WM_XBUTTONDOWN, WM_XBUTTONUP, WM_XBUTTONDBLCLK, WM_NCXBUTTONDOWN, WM_NCXBUTTONUP, or WM_NCXBUTTONDBLCLK, the high-order word specifies which X button was pressed or released, and the low-order word is reserved. This value can be one or more of the following values. Otherwise, mouseData is not used.</para>
            <para>XBUTTON1  The first X button was pressed or released.</para>
            <para>XBUTTON2  The second X button was pressed or released.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT.flags">
            <summary>
            <para>Specifies the event-injected flag. An application can use the following value to test the mouse flags. </para>
            <para>LLMHF_INJECTED Test the event-injected flag.</para>
            <para>0  Specifies whether the event was injected. The value is 1 if the event was injected; otherwise, it is 0.</para>
            <para>1-15  Reserved.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT.time">
            <summary>
            Specifies the time stamp for this message. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.MSLLHOOKSTRUCT.dwExtraInfo">
            <summary>
            Specifies extra information associated with the message.   
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.NMHDR">
            <summary>
            Contains information about a notification message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.NMHDR.hwndFrom">
            <summary>
            A window handle to the control sending the message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.NMHDR.idFrom">
            <summary>
            An identifier of the control sending the message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.NMHDR.code">
            <summary>
            A notification code. This member can be one of the common notification codes (see Notifications under General Control Reference), or it can be a control-specific notification code.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.POINT">
            <summary>
            The POINT structure defines the x- and y- coordinates of a point. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.POINT.x">
            <summary>
            Specifies the x-coordinate of the point.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.POINT.y">
            <summary>
            Specifies the y-coordinate of the point. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.POINT.#ctor(System.IntPtr)">
            <summary>
            Creates a new point, unpacking its signed coordinates from an LPARAM, using the <see cref="M:JetBrains.Interop.WinApi.Macros.GET_X_LPARAM(System.IntPtr)"/> and <see cref="M:JetBrains.Interop.WinApi.Macros.GET_Y_LPARAM(System.IntPtr)"/> functions.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.POINT.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES">
            <summary>
            The <see cref="T:JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES"/> structure contains the security descriptor for an object and specifies whether the handle retrieved by specifying this structure is inheritable. This structure provides security settings for objects created by various functions, such as CreateFile, CreatePipe, CreateProcess, RegCreateKeyEx, or RegSaveKeyEx.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES.nLength">
            <summary>
            The size, in bytes, of this structure. Set this value to the size of the SECURITY_ATTRIBUTES structure.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES.lpSecurityDescriptor">
            <summary>
            A pointer to a security descriptor for the object that controls the sharing of it. If NULL is specified for this member, the object is assigned the default security descriptor of the calling process. This is not the same as granting access to everyone by assigning a NULL discretionary access control list (DACL). The default security descriptor is based on the default DACL of the access token belonging to the calling process. By default, the default DACL in the access token of a process allows access only to the user represented by the access token. If other users must access the object, you can either create a security descriptor with the appropriate access, or add ACEs to the DACL that grants access to a group of users.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SECURITY_ATTRIBUTES.bInheritHandle">
            <summary>
            A Boolean value that specifies whether the returned handle is inherited when a new process is created. If this member is TRUE, the new process inherits the handle.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SERVICE_STATUS_PROCESS.dwServiceType">
            <summary>
            See <see cref="T:JetBrains.Interop.WinApi.ServiceType"/>
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SERVICE_STATUS_PROCESS.dwCurrentState">
            <summary>
            See <see cref="T:JetBrains.Interop.WinApi.ServiceState"/>
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SERVICE_STATUS_PROCESS.dwControlsAccepted">
            <summary>
            See <see cref="T:JetBrains.Interop.WinApi.ServiceAccept"/>
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SERVICE_STATUS_PROCESS.dwServiceFlags">
            <summary>
            See <see cref="T:JetBrains.Interop.WinApi.ServiceFlags"/>
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WinDef">
            <summary>
            Assorted constants.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.CBM_INIT">
            <summary>
            /* constants for CreateDIBitmap */
            /* initialize bitmap */
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.DesktopDefault">
            <summary>
            The name of the input desktop in the interactive window station.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.MAXIMUM_WAIT_OBJECTS">
            <summary>
            Maximum number of wait objects.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.SizeOfVariant">
            <summary>
            Size of the <c>VARIANT</c> / <c>VARIANTARG</c> COM structures.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.USER_TIMER_MAXIMUM">
            <summary>
            The SetTimer function creates a timer with the specified time-out value.
            uElapse
            [in] Specifies the time-out value, in milliseconds. 
            Windows NT/2000/XP: If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to 1.
            Windows 2000/XP: If uElapse is less than USER_TIMER_MINIMUM, the timeout is set to USER_TIMER_MINIMUM.
            Windows Server 2003: If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to USER_TIMER_MAXIMUM.
            Windows XP SP2/Windows Server 2003 SP1: If uElapse is less than USER_TIMER_MINIMUM, the timeout is set to USER_TIMER_MINIMUM. If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to USER_TIMER_MAXIMUM.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.USER_TIMER_MINIMUM">
            <summary>
            The SetTimer function creates a timer with the specified time-out value.
            uElapse
            [in] Specifies the time-out value, in milliseconds. 
            Windows NT/2000/XP: If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to 1.
            Windows 2000/XP: If uElapse is less than USER_TIMER_MINIMUM, the timeout is set to USER_TIMER_MINIMUM.
            Windows Server 2003: If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to USER_TIMER_MAXIMUM.
            Windows XP SP2/Windows Server 2003 SP1: If uElapse is less than USER_TIMER_MINIMUM, the timeout is set to USER_TIMER_MINIMUM. If uElapse is greater than USER_TIMER_MAXIMUM, the timeout is set to USER_TIMER_MAXIMUM.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WinDef.WinSta0">
            <summary>
            The interactive window station name, for use with <see cref="M:JetBrains.Interop.WinApi.User32Dll.OpenWindowStationW(System.String,System.Int32,System.UInt32)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WinError">
             <summary>
             winerror.h --  error code definitions for the Win32 API functions.
             </summary>
             <remarks>
            <code>
              Values are 32 bit values laid out as follows:
            
               3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
               1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
              +---+-+-+-----------------------+-------------------------------+
              |Sev|C|R|     Facility          |               Code            |
              +---+-+-+-----------------------+-------------------------------+
            
              where
            
                  Sev - is the severity code
            
                      00 - Success
                      01 - Informational
                      10 - Warning
                      11 - Error
            
                  C - is the Customer code flag
            
                  R - is a reserved bit
            
                  Facility - is the facility code
            
                  Code - is the facility's status code
             </code>
             </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Gdi32Dll">
            <summary>
            User32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.BitBlt(System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,System.UInt32)">
            <summary>
            The BitBlt function performs a bit-block transfer of the color data corresponding to a rectangle of pixels from the specified source device context into a destination device context.
            </summary>
            <param name="hdcDest">handle to destination DC</param>
            <param name="nXDest">x-coord of destination upper-left corner</param>
            <param name="nYDest">y-coord of destination upper-left corner</param>
            <param name="nWidth">width of destination rectangle</param>
            <param name="nHeight">height of destination rectangle</param>
            <param name="hdcSrc">handle to source DC</param>
            <param name="nXSrc">x-coordinate of source upper-left corner</param>
            <param name="nYSrc">y-coordinate of source upper-left corner</param>
            <param name="dwRop">raster operation code. Use <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations"/>.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateCompatibleDC(System.Void*)">
            <summary>
            The CreateCompatibleDC function creates a memory device context (DC) compatible with the specified device. 
            </summary>
            <param name="hdc">Handle to an existing DC. If this handle is NULL, the function creates a memory DC compatible with the application's current screen.</param>
            <returns>If the function succeeds, the return value is the handle to a memory DC. If the function fails, the return value is NULL.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateDCW(System.String,System.String,System.String,System.Void*)">
            <summary>
            The CreateDC function creates a device context (DC) for a device using the specified name. 
            </summary>
            <param name="lpszDriver">Windows 95/98/Me: The lpszDriver parameter can be NULL, WINSPL16 (a print provider), or (to obtain a display DC) it can be either the null-terminated string DISPLAY or the device name of a specific display device. If lpszDevice specifies a particular device, you must use NULL for lpszDriver. 
            Windows NT 4.0: Pointer to a null-terminated character string that specifies either DISPLAY or the name of a print provider, which is usually WINSPOOL. 
            Windows 2000/XP: Pointer to a null-terminated character string that specifies either DISPLAY or the name of a specific display device or the name of a print provider, which is usually WINSPOOL. </param>
            <param name="lpszDevice">[in] Pointer to a null-terminated character string that specifies the name of the specific output device being used, as shown by the Print Manager (for example, Epson FX-80). It is not the printer model name. The lpszDevice parameter must be used. 
            To obtain valid names for displays, call EnumDisplayDevices. 
            If lpszDriver is DISPLAY or the device name of a specific display device, then lpszDevice must be NULL or that same device name. If lpszDevice is NULL, then a DC is created for the primary display device. 
            Windows NT 3.51 and Windows NT 4.0: There is only one (thus the primary) display device. Set lpszDevice to NULL. 
            Windows 2000 and later: If there are multiple monitors on the system, calling CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL) will create a DC covering all the monitors. </param>
            <param name="lpszOutput">This parameter is ignored and should be set to NULL. It is provided only for compatibility with 16-bit Windows.</param>
            <param name="lpInitData">[in] Pointer to a DEVMODE structure containing device-specific initialization data for the device driver. The DocumentProperties function retrieves this structure filled in for a specified device. The lpInitData parameter must be NULL if the device driver is to use the default initialization (if any) specified by the user. 
            If lpszDriver is DISPLAY, then lpInitData must be NULL. The display device's current DEVMODE is used</param>
            <returns>If the function succeeds, the return value is the handle to a DC for the specified device. If the function fails, the return value is NULL. The function will return NULL for a DEVMODE structure other than the current DEVMODE.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateDIBSection(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO*,System.UInt32,System.Void**,System.Void*,System.Int32)">
            <summary>
            The CreateDIBSection function creates a DIB that applications can write to directly. The function gives you a pointer to the location of the bitmap bit values. You can supply a handle to a file-mapping object that the function will use to create the bitmap, or you can let the system allocate the memory for the bitmap.
            </summary>
            <param name="hdc">handle to DC</param>
            <param name="pbmi">bitmap data</param>
            <param name="iUsage">data type indicator. Use <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.DibColors"/>.</param>
            <param name="ppvBits">bit values</param>
            <param name="hSection">handle to file mapping object</param>
            <param name="dwOffset">offset to bitmap bit values</param>
            <returns>If the function succeeds, the return value is a handle to the newly created DIB, and *ppvBits points to the bitmap bit values. 
            If the function fails, the return value is NULL, and *ppvBits is NULL. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateDIBitmap(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER*,System.UInt32,System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO*,System.UInt32)">
            <summary>
            The CreateDIBitmap function creates a compatible bitmap (DDB) from a DIB and, optionally, sets the bitmap bits.
            </summary>
            <param name="hdc">handle to DC</param>
            <param name="lpbmih">bitmap data</param>
            <param name="fdwInit">initialization option</param>
            <param name="lpbInit">initialization data</param>
            <param name="lpbmi">color-format data</param>
            <param name="fuUsage">color-data usage. Use <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.DibColors"/>.</param>
            <returns>If the function succeeds, the return value is a handle to the compatible bitmap. 
            If the function fails, the return value is NULL.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.CreatePen(System.Int32,System.Int32,System.UInt32)">
            <summary>
            The CreatePen function creates a logical pen that has the specified style, width, and color. The pen can subsequently be selected into a device context and used to draw lines and curves. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.DeleteDC(System.Void*)">
            <summary>
            The DeleteDC function deletes the specified device context (DC).
            </summary>
            <param name="hDC">handle to DC</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.DeleteObject(System.Void*)">
            <summary>
            The DeleteObject function deletes a logical pen, brush, font, bitmap, region, or palette, freeing all system resources associated with the object. After the object is deleted, the specified handle is no longer valid. 
            </summary>
            <param name="hGDIObj">[in] Handle to a logical pen, brush, font, bitmap, region, or palette. </param>
            <returns>If the function succeeds, the return value is nonzero.
            If the specified handle is not valid or is currently selected into a DC, the return value is zero. 
            Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
            <remarks>
            Do not delete a drawing object (pen or brush) while it is still selected into a DC.
            When a pattern brush is deleted, the bitmap associated with the brush is not deleted. The bitmap must be deleted independently.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.GdiFlush">
            <summary>
            The GdiFlush function flushes the calling thread's current batch.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.GetStockObject(System.Int32)">
            <summary>
            The GetStockObject function retrieves a handle to one of the stock pens, brushes, fonts, or palettes.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.SelectObject(System.Void*,System.Void*)">
            <summary>
            The SelectObject function selects an object into the specified device context (DC). The new object replaces the previous object of the same type. 
            </summary>
            <param name="hDC">[in] Handle to the DC. </param>
            <param name="hGDIObj">[in] Handle to the object to be selected. The specified object must have been created by using one of the following functions. 
            Object Functions 
            Bitmap CreateBitmap, CreateBitmapIndirect, CreateCompatibleBitmap, CreateDIBitmap, CreateDIBSection (Bitmaps can be selected for memory DCs only, and for only one DC at a time.)
            Brush CreateBrushIndirect, CreateDIBPatternBrush, CreateDIBPatternBrushPt, CreateHatchBrush, CreatePatternBrush, CreateSolidBrush 
            Font CreateFont, CreateFontIndirect 
            Pen CreatePen, CreatePenIndirect 
            Region CombineRgn, CreateEllipticRgn, CreateEllipticRgnIndirect, CreatePolygonRgn, CreateRectRgn, CreateRectRgnIndirect
            </param>
            <returns>
            If the selected object is not a region and the function succeeds, the return value is a handle to the object being replaced. If the selected object is a region and the function succeeds, the return value is one of the following values.
            Value Meaning 
            SIMPLEREGION Region consists of a single rectangle. 
            COMPLEXREGION Region consists of more than one rectangle. 
            NULLREGION Region is empty. 
            If an error occurs and the selected object is not a region, the return value is NULL. Otherwise, it is HGDI_ERROR. 
            </returns>
            <remarks>
            This function returns the previously selected object of the specified type. An application should always replace a new object with the original, default object after it has finished drawing with the new object. 
            An application cannot select a bitmap into more than one DC at a time. 
            ICM: If the object being selected is a brush or a pen, color management is performed. 
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Gdi32Dll.StretchBlt(System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32)">
            <summary>
            The StretchBlt function copies a bitmap from a source rectangle into a destination rectangle, stretching or compressing the bitmap to fit the dimensions of the destination rectangle, if necessary. The system stretches or compresses the bitmap according to the stretching mode currently set in the destination device context. 
            </summary>
            <param name="hdcDest">[in] Handle to the destination device context.</param>
            <param name="nXOriginDest">[in] Specifies the x-coordinate, in logical units, of the upper-left corner of the destination rectangle. </param>
            <param name="nYOriginDest">[in] Specifies the y-coordinate, in logical units, of the upper-left corner of the destination rectangle. </param>
            <param name="nWidthDest">[in] Specifies the width, in logical units, of the destination rectangle. </param>
            <param name="nHeightDest">[in] Specifies the height, in logical units, of the destination rectangle.</param>
            <param name="hdcSrc">[in] Handle to the source device context. </param>
            <param name="nXOriginSrc">[in] Specifies the x-coordinate, in logical units, of the upper-left corner of the source rectangle.</param>
            <param name="nYOriginSrc">[in] Specifies the y-coordinate, in logical units, of the upper-left corner of the source rectangle.</param>
            <param name="nWidthSrc">[in] Specifies the width, in logical units, of the source rectangle. </param>
            <param name="nHeightSrc">[in] Specifies the height, in logical units, of the source rectangle. </param>
            <param name="dwRop">[in] Specifies the raster operation to be performed. Raster operation codes define how the system combines colors in output operations that involve a brush, a source bitmap, and a destination bitmap. See BitBlt for a list of common raster operation codes (ROPs). Note that the CAPTUREBLT ROP generally cannot be used for printing device contexts. Use the <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations"/> enum.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. Windows NT/2000/XP: To get extended error information, call GetLastError. </returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.HwndSpecial">
            <summary>
            Special HWND values.
            Cast to an <see cref="T:System.IntPtr"/> or a <see cref="T:System.Void"/>* when using.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.KeyStateMasks">
            <summary>
            Key State Masks for Mouse Messages.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PenStyles">
            <summary>
            Pen Styles.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.PrintWindowFlags">
            <summary>
            Specifies the drawing options [for WM_PRINT]. You can combine one or more of the following flags.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_CHECKVISIBLE">
            <summary>
            Draw the window only if it is visible.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_NONCLIENT">
            <summary>
            Draw the non-client area of the window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_CLIENT">
            <summary>
            Draw the client area of the window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_ERASEBKGND">
            <summary>
            Erase the background before drawing the window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_CHILDREN">
            <summary>
            Draw all visible child windows.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.PrintWindowFlags.PRF_OWNED">
            <summary>
            Draw all owned windows.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WmActivateCodes">
            <summary>
            WM_ACTIVATE wParam loword value.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WmActivateCodes.Inactive">
            <summary>
            Deactivated.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WmActivateCodes.Active">
            <summary>
            Activated by some method other than a mouse click (for example, by a call to the <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetActiveWindow(System.Void*)"/> function or by use of the keyboard interface to select the window).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WmActivateCodes.ClickActive">
            <summary>
            Activated by a mouse click.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WmMouseActivateReturnCodes">
            <summary>
            <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_MOUSEACTIVATE"/> return codes.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.HResultHelpers">
            <summary>
            Helper methods related to the <c>HRESULT</c> type.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32,System.Int32[])">
            <summary>
            Checks the given <c>HRESULT</c>, if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>), and is not contained in <paramref name="expectedHRFailure"/>, then an exception-from-hresult is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(JetBrains.Interop.WinApi.HResults)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(System.Int32,System.String)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The comment is used in case of the failure only.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(JetBrains.Interop.WinApi.HResults,System.String)">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The comment is used in case of the failure only.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.Assert(JetBrains.Interop.WinApi.HResults,System.Action{System.Exception})">
            <summary>
            Checks the given <c>HRESULT</c>, and throws an exception if it's a failure one (<see cref="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)"/>).
            The FComment function is called in case of the failure only, should use <see cref="!:ExceptionEx.AddData"/> to contribute to the exception report.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(JetBrains.Interop.WinApi.HResults)">
            <summary>
            The <c>FAILED</c> WinAPI Macro.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.FAILED(System.Int32)">
            <summary>
            The <c>FAILED</c> WinAPI Macro.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.SUCCEEDED(JetBrains.Interop.WinApi.HResults)">
            <summary>
            The <c>SUCCEEDED</c> WinAPI Macro.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.HResultHelpers.SUCCEEDED(System.Int32)">
            <summary>
            The <c>SUCCEEDED</c> WinAPI Macro.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Kernel32Dll">
            <summary>
            Kernel32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CloseHandle(System.Void*)">
            <summary>
            Closes an open object handle.
            </summary>
            <param name="hObject">A valid handle to an open object.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. If the application is running under a debugger, the function will throw an exception if it receives either a handle value that is not valid or a pseudo-handle value. This can happen if you close a handle twice, or if you call CloseHandle on a handle returned by the FindFirstFile function.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.ConvertThreadToFiber(System.Void*)">
            <summary>
            Converts the current thread into a fiber. You must convert a thread into a fiber before you can schedule other fibers.
            </summary>
            <param name="lpParameter">A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the GetFiberData macro.</param>
            <returns>If the function succeeds, the return value is the address of the fiber. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CreateFiber(System.IntPtr,System.Void*,System.Void*)">
            <summary>
            Allocates a fiber object, assigns it a stack, and sets up execution to begin at the specified start address, typically the fiber function. This function does not schedule the fiber. To specify both a commit and reserve stack size, use the CreateFiberEx function.
            </summary>
            <param name="dwStackSize">The initial size of the stack, in bytes. If this parameter is zero, the new fiber uses the default stack size for the executable. For more information, see Thread Stack Size.</param>
            <param name="lpStartAddress">A pointer to the application-defined function to be executed by the fiber and represents the starting address of the fiber. Execution of the newly created fiber does not begin until another fiber calls the SwitchToFiber function with this address. For more information of the fiber callback function, see FiberProc.</param>
            <param name="lpParameter">A pointer to a variable that is passed to the fiber. The fiber can retrieve this data by using the GetFiberData macro.</param>
            <returns>If the function succeeds, the return value is the address of the fiber. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.CreateToolhelp32Snapshot(System.UInt32,System.UInt32)">
            <summary>
            Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these processes.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.DeleteFiber(System.Void*)">
            <summary>
            Deletes an existing fiber.
            </summary>
            <param name="lpFiber">The address of the fiber to be deleted.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.FindResourceW(System.Void*,System.String,System.String)">
            <summary>
            Determines the location of a resource with the specified type and name in the specified module. To specify a language, use the FindResourceEx function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetCurrentProcess">
            <summary>
            Retrieves a pseudo handle for the current process.
            </summary>
            <returns>The return value is a pseudo handle to the current process.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetCurrentProcessId">
            <summary>
            Retrieves the process identifier of the calling process.
            </summary>
            <returns>The return value is the process identifier of the calling process.</returns>
            <remarks>Until the process terminates, the process identifier uniquely identifies the process throughout the system.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetCurrentThreadId">
            <summary>
            The GetCurrentThreadId function retrieves the thread identifier of the calling thread.
            Note: same as <see cref="M:System.AppDomain.GetCurrentThreadId"/>, but doesn't raise the “Obsolete” warning.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetFileAttributesW(System.String)">
            <summary>
            Retrieves file system attributes for a specified file or directory.
            </summary>
            <param name="lpFileName">[in] The name of the file or directory.</param>
            <returns>If the function succeeds, the return value contains the attributes of the specified file or directory.
            If the function fails, the return value is INVALID_FILE_ATTRIBUTE.
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetModuleFileNameW(System.Void*,System.Char*,System.UInt32)">
            <summary>
            Retrieves the fully-qualified path for the file that contains the specified module. The module must have been loaded by the current process. 
            To locate the file for a module that was loaded by another process, use the GetModuleFileNameEx function. 
            </summary>
            <param name="hModule">
            A handle to the loaded module whose path is being requested. If this parameter is NULL, GetModuleFileName retrieves the path of the executable file of the current process.
            The GetModuleFileName function does not retrieve the path for modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information, see LoadLibraryEx. 
            </param>
            <param name="lpFilename">
            A pointer to a buffer that receives the fully-qualified path of the module. If the length of the path is less than the size that the nSize parameter specifies, the function succeeds and the path is returned as a null-terminated string. 
            If the length of the path exceeds the size that the nSize parameter specifies, the function succeeds and the string is truncated to nSize characters including the terminating null character. 
            Windows XP/2000:  The string is truncated to nSize characters and is not null terminated. 
            The string returned will use the same format that was specified when the module was loaded. Therefore, the path can be a long or short file name, and can use the prefix "\\?\". For more information, see Naming a File. 
            </param>
            <param name="nSize">The size of the lpFilename buffer, in TCHARs.</param>
            <returns>
            If the function succeeds, the return value is the length of the string that is copied to the buffer, in characters, not including the terminating null character. If the buffer is too small to hold the module name, the string is truncated to nSize characters including the terminating null character, the function returns nSize, and the function sets the last error to ERROR_INSUFFICIENT_BUFFER. 
            Windows XP/2000:  If the buffer is too small to hold the module name, the function returns nSize. The last error code remains ERROR_SUCCESS. If nSize is zero, the return value is zero and the last error code is ERROR_SUCCESS. 
            If the function fails, the return value is 0 (zero). To get extended error information, call GetLastError. 
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetModuleHandleW(System.String)">
            <summary>
            Retrieves a module handle for the specified module. The module must have been loaded by the calling process. To avoid the race conditions described in the Remarks section, use the GetModuleHandleEx function.
            </summary>
            <param name="lpModuleName">The name of the loaded module (either a .dll or .exe file). If the file name extension is omitted, the default library extension .dll is appended. The file name string can include a trailing point character (.) to indicate that the module name has no extension. The string does not have to specify a path. When specifying a path, be sure to use backslashes (\), not forward slashes (/). The name is compared (case independently) to the names of modules currently mapped into the address space of the calling process. If this parameter is NULL, GetModuleHandle returns a handle to the file used to create the calling process (.exe file). The GetModuleHandle function does not retrieve handles for modules that were loaded using the LOAD_LIBRARY_AS_DATAFILE flag. For more information, see LoadLibraryEx.</param>
            <returns>If the function succeeds, the return value is a handle to the specified module. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetPrivateProfileIntW(System.String,System.String,System.Int32,System.String)">
            <summary>
            Retrieves an integer associated with a key in the specified section of an initialization file. Note: This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetPrivateProfileStringW(System.String,System.String,System.String,System.UInt16*,System.UInt32,System.String)">
            <summary>
            Retrieves a string from the specified section in an initialization file.
            Note: This function is provided only for compatibility with 16-bit Windows-based applications. Applications should store initialization information in the registry.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.GetProcAddress(System.Void*,System.String)">
            <summary>
            Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).
            </summary>
            <param name="hModule">A handle to the DLL module that contains the function or variable. The LoadLibrary or GetModuleHandle function returns this handle.</param>
            <param name="lpProcName">The function or variable name, or the function's ordinal value. If this parameter is an ordinal value, it must be in the low-order word; the high-order word must be zero.</param>
            <returns>If the function succeeds, the return value is the address of the exported function or variable. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.LoadLibraryW(System.String)">
            <summary>
            The LoadLibrary function maps the specified executable module into the address space of the calling process. 
            For additional load options, use the LoadLibraryEx function.
            </summary>
            <param name="lpFileName">[in] Pointer to a null-terminated string that names the executable module (either a .dll or .exe file). The name specified is the file name of the module and is not related to the name stored in the library module itself, as specified by the LIBRARY keyword in the module-definition (.def) file. 
            If the string specifies a path but the file does not exist in the specified directory, the function fails. When specifying a path, be sure to use backslashes (\), not forward slashes (/).
            If the string does not specify a path, the function uses a standard search strategy to find the file. See the Remarks for more information.</param>
            <returns>If the function succeeds, the return value is a handle to the module.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.
            Windows Me/98/95:  If you are using LoadLibrary to load a module that contains a resource whose numeric identifier is greater than 0x7FFF, LoadLibrary fails. If you are attempting to load a 16-bit DLL directly from 32-bit code, LoadLibrary fails. If you are attempting to load a DLL whose subsystem version is greater than 4.0, LoadLibrary fails. If your DllMain function tries to call the Unicode version of a function, LoadLibrary fails.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.LoadResource(System.Void*,System.Void*)">
            <summary>
            Loads the specified resource into global memory. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.LockResource(System.Void*)">
            <summary>
            Locks the specified resource in memory. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.OutputDebugStringW(System.String)">
            <summary>
            The OutputDebugString function sends a string to the debugger for display.
            </summary>
            <param name="lpOutputString">[in] Pointer to the null-terminated string to be displayed.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Process32FirstW(System.Void*,System.Void*)">
            <summary>
            Retrieves information about the first process encountered in a system snapshot.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.QueryPerformanceCounter(System.UInt64*)">
            <summary>
            The QueryPerformanceCounter function retrieves the current value of the high-resolution performance counter.
            </summary>
            <param name="lpPerformanceCount">[out] Pointer to a variable that receives the current performance-counter value, in counts.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
            <remarks>On a multiprocessor computer, it should not matter which processor is called. However, you can get different results on different processors due to bugs in the basic input/output system (BIOS) or the hardware abstraction layer (HAL). To specify processor affinity for a thread, use the SetThreadAffinityMask function. </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.QueryPerformanceFrequency(System.UInt64*)">
            <summary>
            The QueryPerformanceFrequency function retrieves the frequency of the high-resolution performance counter, if one exists. The frequency cannot change while the system is running.
            </summary>
            <param name="lpFrequency">[out] Pointer to a variable that receives the current performance-counter frequency, in counts per second. If the installed hardware does not support a high-resolution performance counter, this parameter can be zero. </param>
            <returns>If the installed hardware supports a high-resolution performance counter, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. For example, if the installed hardware does not support a high-resolution performance counter, the function fails. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.RtlCopyMemory(System.Void*,System.Void*,System.UIntPtr)">
            <summary>
            The <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.RtlCopyMemory(System.Void*,System.Void*,System.UIntPtr)"/> routine copies the contents of one buffer to another.
            </summary>
            <param name="Destination">Pointer to the destination of the move.</param>
            <param name="Source">Pointer to the memory to be copied.</param>
            <param name="Length">Specifies the number of bytes to be copied.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.RtlMoveMemory(System.Void*,System.Void*,System.UIntPtr)">
            <summary>
            The <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.RtlMoveMemory(System.Void*,System.Void*,System.UIntPtr)"/> routine moves memory either forward or backward, aligned or unaligned, in 4-byte blocks, followed by any remaining bytes.
            </summary>
            <param name="Destination">Pointer to the destination of the move.</param>
            <param name="Source">Pointer to the memory to be copied.</param>
            <param name="Length">Specifies the number of bytes to be copied.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.SizeofResource(System.Void*,System.Void*)">
            <summary>
            Returns the size, in bytes, of the specified resource. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.SwitchToFiber(System.Void*)">
            <summary>
            Schedules a fiber. The function must be called on a fiber.
            </summary>
            <param name="lpFiber">The address of the fiber to be scheduled.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.VirtualAlloc(System.Void*,System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            Reserves or commits a region of pages in the virtual address space of the calling process. Memory allocated by this function is automatically initialized to zero, unless MEM_RESET is specified.
            To allocate memory in the address space of another process, use the VirtualAllocEx function.
            </summary>
            <param name="lpAddress">The starting address of the region to allocate. If the memory is being reserved, the specified address is rounded down to the nearest multiple of the allocation granularity. If the memory is already reserved and is being committed, the address is rounded down to the next page boundary. To determine the size of a page and the allocation granularity on the host computer, use the GetSystemInfo function. If this parameter is NULL, the system determines where to allocate the region.</param>
            <param name="dwSize">The size of the region, in bytes. If the lpAddress parameter is NULL, this value is rounded up to the next page boundary. Otherwise, the allocated pages include all pages containing one or more bytes in the range from lpAddress to lpAddress+dwSize. This means that a 2-byte range straddling a page boundary causes both pages to be included in the allocated region.</param>
            <param name="flAllocationType">The type of memory allocation. See <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryAllocationTypes"/>.</param>
            <param name="flProtect">The memory protection for the region of pages to be allocated. If the pages are being committed, you can specify any one of the <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants">memory protection constants</see>.</param>
            <returns>If the function succeeds, the return value is the base address of the allocated region of pages.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.VirtualProtect(System.Void*,System.IntPtr,System.UInt32,System.UInt32*)">
            <summary>
            Changes the protection on a region of committed pages in the virtual address space of the calling process.
            To change the access protection of any process, use the VirtualProtectEx function.
            </summary>
            <param name="lpAddress">A pointer to the base address of the region of pages whose access protection attributes are to be changed. 
            All pages in the specified region must be within the same reserved region allocated when calling the VirtualAlloc or VirtualAllocEx function using MEM_RESERVE. The pages cannot span adjacent reserved regions that were allocated by separate calls to VirtualAlloc or VirtualAllocEx using MEM_RESERVE.The size of the region whose access protection attributes are to be changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</param>
            <param name="dwSize">The size of the region whose access protection attributes are to be changed, in bytes. The region of affected pages includes all pages containing one or more bytes in the range from the lpAddress parameter to (lpAddress+dwSize). This means that a 2-byte range straddling a page boundary causes the protection attributes of both pages to be changed.</param>
            <param name="flNewProtect">The memory protection option. This parameter can be one of the <see cref="T:JetBrains.Interop.WinApi.Declarations.Constants.MemoryProtectionConstants">memory protection constants</see>.
            This value must be compatible with the access protection specified for the pages using VirtualAlloc or VirtualAllocEx.</param>
            <param name="lpflOldProtect">A pointer to a variable that receives the previous access protection value of the first page in the specified region of pages. If this parameter is NULL or does not point to a valid variable, the function fails.</param>
            <returns>If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.VirtualQuery(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION*,System.IntPtr)">
            <summary>
            Retrieves information about a range of pages in the virtual address space of the calling process.
            To retrieve information about a range of pages in the address space of another process, use the VirtualQueryEx function.
            </summary>
            <param name="lpAddress">A pointer to the base address of the region of pages to be queried. This value is rounded down to the next page boundary. To determine the size of a page on the host computer, use the GetSystemInfo function.
            If lpAddress specifies an address above the highest memory address accessible to the process, the function fails with ERROR_INVALID_PARAMETER.
            </param>
            <param name="lpBuffer">A pointer to a <see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.MEMORY_BASIC_INFORMATION"/> structure in which information about the specified page range is returned.</param>
            <param name="dwLength">The size of the buffer pointed to by the lpBuffer parameter, in bytes.</param>
            <returns>The return value is the actual number of bytes returned in the information buffer.
            If the function fails, the return value is zero. To get extended error information, call GetLastError. Possible error values include ERROR_INVALID_PARAMETER.
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.WaitForMultipleObjects(System.UInt32,System.Void**,System.Int32,System.UInt32)">
            <summary>
            Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. To enter an alertable wait state, use the WaitForMultipleObjectsEx function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.WaitForSingleObject(System.Void*,System.UInt32)">
            <summary>
            Waits until the specified object is in the signaled state or the time-out interval elapses. To enter an alertable wait state, use the WaitForSingleObjectEx function. To wait for multiple objects, use the WaitForMultipleObjects.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.WritePrivateProfileStringW(System.String,System.String,System.String,System.String)">
            <summary>
            Copies a string into the specified section of an initialization file.
            Note  This function is provided only for compatibility with 16-bit versions of Windows. Applications should store initialization information in the registry.
            </summary>
            <param name="lpAppName">The name of the section to which the string will be copied. If the section does not exist, it is created. The name of the section is case-independent; the string can be any combination of uppercase and lowercase letters.</param>
            <param name="lpKeyName">The name of the key to be associated with a string. If the key does not exist in the specified section, it is created. If this parameter is NULL, the entire section, including all entries within the section, is deleted.</param>
            <param name="lpString">A null-terminated string to be written to the file. If this parameter is NULL, the key pointed to by the lpKeyName parameter is deleted. 
            Windows Me/98/95:  The system does not support the use of the TAB (\t) character as part of this parameter.</param>
            <param name="lpFileName">The name of the initialization file.
            If the file was created using Unicode characters, the function writes Unicode characters to the file. Otherwise, the function writes ANSI characters.</param>
            <returns>If the function successfully copies the string to the initialization file, the return value is nonzero. If the function fails, or if it flushes the cached version of the most recently accessed initialization file, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.IsWow64Process(System.Void*,System.Boolean@)">
            <summary>
            Determines whether the specified process is running under WOW64.
            </summary>
            <param name="hProcess">Process handle</param>
            <param name="wow64Process">A pointer to a value that is set to TRUE if the process is running under WOW64. If the process is running under 32-bit Windows, the value is set to FALSE. If the process is a 64-bit application running under 64-bit Windows, the value is also set to FALSE.</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Kernel32Dll.Helpers">
            <summary>
            Wrappers for the functions in this DLL.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Kernel32Dll.Helpers._performancefrequency">
            <summary>
            Frequency of the performance counter, for <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetHighPrecisionSystemTime"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.CoCreateInstanceExplicit(System.String,System.Guid)">
            <summary>
            Creates an instance of a COM object without the Registry information, by loading the DLL and invoking its class factory.
            </summary>
            <param name="sDllFilename">Pathname of the DLL.</param>
            <param name="guidClsid">CLSID of the object to create.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetHighPrecisionSystemTime">
            <summary>
            Gets the high-precision system time value, in milliseconds.
            Throws if not supported on the system (unlikely).
            May yield irrelevant data on non-synchronized CPU cores.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetProfileString(System.String,System.String,System.String,System.String)">
            <summary>
            Reads an .ini string.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.GetWin32Resource(System.String,System.String,System.String)">
            <summary>
            Loads a native dll and looks up the resource.
            Throws on errors.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.IsWow64Process">
            <summary>
            Calls the <c>IsWow64Process</c> API function, if one is present on this OS version.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.WaitForSingleObject(System.IntPtr,System.TimeSpan)">
            <summary>
            Waits for the object, returns whether the wait was successful.
            The abandoned state is considered success.
            </summary>
            <param name="handle">Handle to wait for.</param>
            <param name="timeout">Timeout. <see cref="F:System.TimeSpan.Zero"/> to test without waiting, <see cref="F:System.TimeSpan.MaxValue"/> to wait infinitely.</param>
            <returns>Whether the wait has succeeded.</returns>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.DllGetClassObjectDelegate">
            <summary>
            Helper for the <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.CoCreateInstanceExplicit(System.String,System.Guid)"/> function.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Kernel32Dll.Helpers.IsWow64ProcessDelegate">
            <summary>
            Delegate to Kernel32 <c>IsWow64Process</c> API func.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WindowClassStyles">
            <summary>
            “<c>CS_…</c>” window class styles from the <c>RegisterClassEx</c> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_BYTEALIGNCLIENT">
            <summary>
            Aligns the window's client area on a byte boundary (in the x direction). This style affects the width of the window and its horizontal placement on the display. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_BYTEALIGNWINDOW">
            <summary>
            Aligns the window on a byte boundary (in the x direction). This style affects the width of the window and its horizontal placement on the display. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_CLASSDC">
            <summary>
            Allocates one device context to be shared by all windows in the class. Because window classes are process specific, it is possible for multiple threads of an application to create a window of the same class. It is also possible for the threads to attempt to use the device context simultaneously. When this happens, the system allows only one thread to successfully finish its drawing operation.  
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_DBLCLKS">
            <summary>
            Sends a double-click message to the window procedure when the user double-clicks the mouse while the cursor is within a window belonging to the class.  
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_DROPSHADOW">
            <summary>
            Windows XP: Enables the drop shadow effect on a window. The effect is turned on and off through SPI_SETDROPSHADOW. Typically, this is enabled for small, short-lived windows such as menus to emphasize their Z order relationship to other windows. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_GLOBALCLASS">
            <summary>
            Specifies that the window class is an application global class. For more information, see Application Global Classes. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_HREDRAW">
            <summary>
            Redraws the entire window if a movement or size adjustment changes the width of the client area. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_NOCLOSE">
            <summary>
            Disables Close on the window menu. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_OWNDC">
            <summary>
            Allocates a unique device context for each window in the class.  
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_PARENTDC">
            <summary>
            Sets the clipping rectangle of the child window to that of the parent window so that the child can draw on the parent. A window with the CS_PARENTDC style bit receives a regular device context from the system's cache of device contexts. It does not give the child the parent's device context or device context settings. Specifying CS_PARENTDC enhances an application's performance.  
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_SAVEBITS">
            <summary>
            Saves, as a bitmap, the portion of the screen image obscured by a window of this class. When the window is removed, the system uses the saved bitmap to restore the screen image, including other windows that were obscured. Therefore, the system does not send WM_PAINT messages to windows that were obscured if the memory used by the bitmap has not been discarded and if other screen actions have not invalidated the stored image. This style is useful for small windows (for example, menus or dialog boxes) that are displayed briefly and then removed before other screen activity takes place. This style increases the time required to display the window, because the system must first allocate memory to store the bitmap.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowClassStyles.CS_VREDRAW">
            <summary>
            Redraws the entire window if a movement or size adjustment changes the height of the client area. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WindowExStyles">
            <summary>
            Specifies the extended window style of the window being created.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WindowStyles">
            <summary>
            The following styles can be specified wherever a window style is required. After the control has been created, these styles cannot be modified, except as noted.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.ShowWindowCommands">
            <summary>
            <see cref="M:JetBrains.Interop.WinApi.User32Dll.ShowWindow(System.Void*,System.Int32)"/> Commands.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.EditBoxControlMargins">
            <summary>
            <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.EM_SETMARGINS"/> constants.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.EditBoxControlMargins.EC_LEFTMARGIN">
            <summary>
            Sets the left margin.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.EditBoxControlMargins.EC_RIGHTMARGIN">
            <summary>
            Sets the right margin.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.EditBoxControlMargins.EC_USEFONTINFO">
            <summary>
            Rich edit controls: Sets the left and right margins to a narrow width calculated using the text metrics of the control's current font. If no font has been set for the control, the margins are set to zero. The lParam parameter is ignored. Edit controls: The EC_USEFONTINFO value cannot be used in the wParam parameter. It can only be used in the lParam parameter. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.MEMORYSTATUSEX">
            <summary>
            Helper structure for the <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.GlobalMemoryStatusEx(JetBrains.Interop.WinApi.MEMORYSTATUSEX*)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_DEST_TOO_SMALL">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_LOCKED">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_READONLY">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_READONLY_REGION">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_SCC_READONLY">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.BUFFER_E_TIMEOUT">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.MARKER_E_BUFFERDESTROYED">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.MARKER_E_INVALIDATED">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.VIEW_E_LOCATION_HIDDEN">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.VIEW_E_NO_BOOKMARKS">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.VIEW_E_NO_DEBUGGER">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.VIEW_E_USERREADONLY">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.LINKEDUNDO_E_INTERVENING_ACTION">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.UNDO_E_CLIENTABORT">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.TIP_S_ONLYIFNOMARKER">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.STG_E_INVALIDCODEPAGE">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.STG_E_NOTTEXT">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.HResults.STG_S_DATALOSS">
            <summary>
            Visual Studio specific.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.GetAncestorFlags">
            <summary>
            Flags for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetAncestor(System.Void*,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GetAncestorFlags.GA_PARENT">
            <summary>
            Retrieves the parent window. This does not include the owner, as it does with the GetParent function. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GetAncestorFlags.GA_ROOT">
            <summary>
            Retrieves the root window by walking the chain of parent windows.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.GetAncestorFlags.GA_ROOTOWNER">
            <summary>
            Retrieves the owned root window by walking the chain of parent and owner windows returned by GetParent.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS">
            <summary>
            The <c>WINDOWPOS</c> structure contains information about the size and position of a window. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.hwnd">
            <summary>
            Handle to the window. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.hwndInsertAfter">
            <summary>
            Specifies the position of the window in Z order (front-to-back position). This member can be a handle to the window behind which this window is placed, or can be one of the special values listed with the SetWindowPos function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.x">
            <summary>
            Specifies the position of the left edge of the window. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.y">
            <summary>
            Specifies the position of the top edge of the window. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.cx">
            <summary>
            Specifies the window width, in pixels. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.cy">
            <summary>
            Specifies the window height, in pixels. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.WINDOWPOS.flags">
            <summary>
            Specifies the window position. This member can be one or more of the following values.  See <see cref="T:JetBrains.Interop.WinApi.SetWindowPosFlags"/> for details.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoSizeW(System.String,System.UInt32*)">
            <summary>
            Determines whether the operating system can retrieve version information for a specified file. If version information is available, <see cref="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoSizeW(System.String,System.UInt32*)"/> returns the size, in bytes, of that information. 
            </summary>
            <param name="lptstrFilename">[in] Pointer to a null-terminated string that specifies the name of the file of interest. The function uses the search sequence specified by the LoadLibrary function. Windows 95/98/Me: The short path form of the specified file name must be less than 126 characters.</param>
            <param name="lpdwHandle">[out] Pointer to a variable that the function sets to zero.</param>
            <returns>If the function succeeds, the return value is the size, in bytes, of the file's version information. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoW(System.String,System.UInt32,System.UInt32,System.Void*)">
            <summary>
            Retrieves version information for the specified file. 
            </summary>
            <param name="lptstrFilename">[in] Pointer to a null-terminated string that specifies the name of the file of interest. If a full path is not specified, the function uses the search sequence specified by the LoadLibrary function.Windows 95/98/Me: The short path form of the specified file name must be less than 126 characters.</param> 
            <param name="dwHandle">This parameter is ignored.</param>
            <param name="dwLen">[in] Specifies the size, in bytes, of the buffer pointed to by the lpData parameter. Call the <see cref="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoSizeW(System.String,System.UInt32*)"/> function first to determine the size, in bytes, of a file's version information. The dwLen member should be equal to or greater than that value. If the buffer pointed to by lpData is not large enough, the function truncates the file's version information to the size of the buffer.</param>
            <param name="lpData">[out] Pointer to a buffer that receives the file-version information. You can use this value in a subsequent call to the <see cref="M:JetBrains.Interop.WinApi.VersionDll.VerQueryValueW(System.Void*,System.String,System.Void**,System.UInt32*)"/> function to retrieve data from the buffer.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.VersionDll.VerQueryValueW(System.Void*,System.String,System.Void**,System.UInt32*)">
            <summary>
            The <see cref="M:JetBrains.Interop.WinApi.VersionDll.VerQueryValueW(System.Void*,System.String,System.Void**,System.UInt32*)"/> function retrieves specified version information from the specified version-information resource. To retrieve the appropriate resource, before you call <see cref="M:JetBrains.Interop.WinApi.VersionDll.VerQueryValueW(System.Void*,System.String,System.Void**,System.UInt32*)"/>, you must first call the <see cref="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoSizeW(System.String,System.UInt32*)"/> function, and then the <see cref="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoW(System.String,System.UInt32,System.UInt32,System.Void*)"/> function.
            </summary>
            <param name="pBlock">[in] Pointer to the buffer containing the version-information resource returned by the <see cref="M:JetBrains.Interop.WinApi.VersionDll.GetFileVersionInfoW(System.String,System.UInt32,System.UInt32,System.Void*)"/> function. </param>
            <param name="lpSubBlock">[in] Pointer to a zero-terminated string specifying which version-information value to retrieve. The string must consist of names separated by backslashes (\) and it must have one of the following forms. 
            <para><c>\</c></para>
            <para>Specifies the root block. The function retrieves a pointer to the VS_FIXEDFILEINFO structure for the version-information resource.</para>
            <para><c>\VarFileInfo\Translation</c></para>
            <para>Specifies the translation array in a Var variable information structure—the Value member of this structure. The function retrieves a pointer to this array of language and code page identifiers. An application can use these identifiers to access a language-specific StringTable /// structure (using the szKey member) in the version-information resource.</para>
            <para><c>\StringFileInfo\lang-codepage\string-name</c></para>
            <para>Specifies a value in a language-specific StringTable structure. The lang-codepage name is a concatenation of a language and code page identifier pair found as a DWORD in the translation array for the resource. Here the lang-codepage name must be specified as a hexadecimal string. The string-name name must be one of the predefined strings described in the following Remarks section. The function retrieves a string value specific to the language and code page indicated. </para>
            </param>
            <param name="lplpBuffer">[out] When this method returns, contains the address of a pointer to the requested version information in the buffer pointed to by pBlock. The memory pointed to by lplpBuffer is freed when the associated pBlock memory is freed. </param>
            <param name="puLen">[out] When this method returns, contains a pointer to the size of the requested data pointed to by lplpBuffer: for version information values, the length in TCHARs of the string stored at lplpBuffer; for translation array values, the size in bytes of the array stored at lplpBuffer; and for root block, the size in bytes of the structure.</param>
            <returns>If the specified version-information structure exists, and version information is available, the return value is nonzero. If the address of the length buffer is zero, no value is available for the specified version-information name. If the specified name does not exist or the specified resource is not valid, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.VersionDll.Helpers.GetFileVersionInfo(System.IO.FileInfo)">
            <summary>
            Gets the WinAPI file version of a native file.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WinInetDll">
            <summary>
            WinInet.dll functions.
            Must be 64bit-safe.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.WinInetDll.Helpers.InternetGetCookie(System.String)">
            <summary>
            Gets the system HTTP cookie.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.WinInetDll.Helpers.InternetSetCookie(System.String,System.String)">
            <summary>
            Sets a system HTTP cookie.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.DibColors">
            <summary>
            Color usage constants for <see cref="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateDIBSection(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO*,System.UInt32,System.Void**,System.Void*,System.Int32)"/>, <see cref="M:JetBrains.Interop.WinApi.Gdi32Dll.CreateDIBitmap(System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFOHEADER*,System.UInt32,System.Void*,JetBrains.Interop.WinApi.Declarations.Structures.BITMAPINFO*,System.UInt32)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DibColors.DIB_RGB_COLORS">
            <summary>
            The BITMAPINFO structure contains an array of literal RGB values.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.DibColors.DIB_PAL_COLORS">
            <summary>
            The bmiColors member is an array of 16-bit indexes into the logical palette of the device context specified by hdc.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Modules.UI.ControlPaintUnsafe">
            <summary>
            Encapsulates the utility classes for painting the controls.
            </summary>
        </member>
        <member name="T:JetBrains.Util.NoReorder">
            <summary>
            Prevents the Member Reordering feature from tossing members of the marked class.
            </summary>
            <remarks>
            The attribute must be mentioned in your member reordering patterns.
            </remarks>
        </member>
        <member name="T:JetBrains.Interop.WinApi.User32Dll">
            <summary>
            User32.dll functions.
            Must be 64bit-safe.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.BringWindowToTop(System.Void*)">
            <summary>
            The BringWindowToTop function brings the specified window to the top of the Z order. If the window is a top-level
            window, it is activated. If the window is a child window, the top-level parent window associated with the child window is activated.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ClientToScreen(System.Void*,JetBrains.Interop.WinApi.POINT*)">
            <summary>
            The ClientToScreen function converts the client-area coordinates of a specified point to screen coordinates. 
            </summary>
            <param name="hWnd">[in] Handle to the window whose client area is used for the conversion. </param>
            <param name="lpPoint">[in/out] Pointer to a POINT structure that contains the client coordinates to be converted. The new screen coordinates are copied into this structure if the function succeeds. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.CreateDesktopW(System.String,System.String,System.Void*,System.UInt32,System.UInt32,System.Void*)">
            <summary>
            Creates a new desktop, associates it with the current window station of the calling process, and assigns it to the calling thread. The calling process must have an associated window station, either assigned by the system at process creation time or set by the SetProcessWindowStation function.
            </summary>
            <param name="lpszDesktop">The name of the desktop to be created. Desktop names are case-insensitive and may not contain backslash characters (\).</param>
            <param name="lpszDevice">Reserved; must be NULL.</param>
            <param name="pDevmode">Reserved; must be NULL.</param>
            <param name="dwFlags">This parameter can be zero or the following value. <c>DF_ALLOWOTHERACCOUNTHOOK</c> <c>0x0001</c> Enables processes running in other accounts on the desktop to set hooks in this process. </param>
            <param name="dwDesiredAccess">The access to the desktop. For a list of values, see Desktop Security and Access Rights. This parameter must include the DESKTOP_CREATEWINDOW access right, because internally CreateDesktop uses the handle to create a window.</param>
            <param name="lpsa">A pointer to a SECURITY_ATTRIBUTES structure that determines whether the returned handle can be inherited by child processes. If lpsa is NULL, the handle cannot be inherited. The lpSecurityDescriptor member of the structure specifies a security descriptor for the new desktop. If this parameter is NULL, the desktop inherits its security descriptor from the parent window station.</param>
            <returns>If the function succeeds, the return value is a handle to the newly created desktop. If the specified desktop already exists, the function succeeds and returns a handle to the existing desktop. When you are finished using the handle, call the CloseDesktop function to close it. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.DestroyIcon(System.Void*)">
            <summary>
            Destroys an icon and frees any memory the icon occupied. 
            </summary>
            <param name="hIcon">[in] Handle to the icon to be destroyed. The icon must not be in use. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. </returns>
            <remarks>
            It is only necessary to call DestroyIcon for icons and cursors created with the following functions: CreateIconFromResourceEx (if called without the LR_SHARED flag), CreateIconIndirect, and CopyIcon. Do not use this function to destroy a shared icon. A shared icon is valid as long as the module from which it was loaded remains in memory. The following functions obtain a shared icon: LoadIcon, LoadImage (if you use the LR_SHARED flag), CopyImage (if you use the LR_COPYRETURNORG flag and the hImage parameter is a shared icon), CreateIconFromResource, CreateIconFromResourceEx (if you use the LR_SHARED flag) 
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.DestroyWindow(System.Void*)">
            <summary>
            The DestroyWindow function destroys the specified window. The function sends WM_DESTROY and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus from it. The function also destroys the window's menu, flushes the thread message queue, destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if the window is at the top of the viewer chain). If the specified window is a parent or owner window, DestroyWindow automatically destroys the associated child or owned windows when it destroys the parent or owner window. The function first destroys child or owned windows, and then it destroys the parent or owner window. DestroyWindow also destroys modeless dialog boxes created by the CreateDialog function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.DispatchMessageW(JetBrains.Interop.WinApi.MSG*)">
            <summary>
            The DispatchMessage function dispatches a message to a window procedure. It is typically used to dispatch a message retrieved by the GetMessage function.
            </summary>
            <param name="lpmsg">[in] Pointer to an MSG structure that contains the message.</param>
            <returns>The return value specifies the value returned by the window procedure. Although its meaning depends on the message being dispatched, the return value generally is ignored.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.EnableWindow(System.Void*,System.Int32)">
            <summary>
            The EnableWindow function enables or disables mouse and keyboard input to the specified window or control. When input is disabled, the window does not receive input such as mouse clicks and key presses. When input is enabled, the window receives all input.
            </summary>
            <param name="hWnd">[in] Handle to the window to be enabled or disabled.</param>
            <param name="bEnable">[in] Specifies whether to enable or disable the window. If this parameter is TRUE, the window is enabled. If the parameter is FALSE, the window is disabled.</param>
            <returns>If the window was previously disabled, the return value is nonzero. If the window was not previously disabled, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.EnumChildWindows(System.Void*,System.Void*,System.IntPtr)">
            <summary>
            The EnumChildWindows function enumerates the child windows that belong to the specified parent window by passing the handle to each child window, in turn, to an application-defined callback function. EnumChildWindows continues until the last child window is enumerated or the callback function returns FALSE.
            </summary>
            <param name="hWndParent">[in] Handle to the parent window whose child windows are to be enumerated. If this parameter is NULL, this function is equivalent to EnumWindows. Windows 95/98/Me: hWndParent cannot be NULL.</param>
            <param name="lpEnumFunc">[in] Pointer to an application-defined callback function. For more information, see EnumChildProc.</param>
            <param name="lParam">[in] Specifies an application-defined value to be passed to the callback function.</param>
            <returns>Not used.</returns>
            <remarks>If a child window has created child windows of its own, EnumChildWindows enumerates those windows as well. A child window that is moved or repositioned in the Z order during the enumeration process will be properly enumerated. The function does not enumerate a child window that is destroyed before being enumerated or that is created during the enumeration process. </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.EnumThreadWindows(System.UInt32,System.Void*,System.IntPtr)">
            <summary>
            The EnumThreadWindows function enumerates all nonchild windows associated with a thread by passing the handle to each window, in turn, to an application-defined callback function. EnumThreadWindows continues until the last window is enumerated or the callback function returns FALSE. To enumerate child windows of a particular window, use the EnumChildWindows function. 
            </summary>
            <param name="dwThreadId">[in] Identifies the thread whose windows are to be enumerated. </param>
            <param name="lpfn">[in] Pointer to an application-defined callback function. For more information, see EnumThreadWndProc. </param>
            <param name="lParam">[in] Specifies an application-defined value to be passed to the callback function. </param>
            <returns>If the callback function returns TRUE for all windows in the thread specified by dwThreadId, the return value is TRUE. If the callback function returns FALSE on any enumerated window, or if there are no windows found in the thread specified by dwThreadId, the return value is FALSE.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.EnumWindows(System.Void*,System.IntPtr)">
            <summary>
            The EnumWindows function enumerates all top-level windows on the screen by passing the handle to each window, in turn, to an application-defined callback function. EnumWindows continues until the last top-level window is enumerated or the callback function returns FALSE. 
            </summary>
            <param name="lpEnumFunc">[in] Pointer to an application-defined callback function. For more information, see EnumWindowsProc. </param>
            <param name="lParam">[in] Specifies an application-defined value to be passed to the callback function. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.  If EnumWindowsProc returns zero, the return value is also zero. In this case, the callback function should call SetLastError to obtain a meaningful error code to be returned to the caller of EnumWindows. </returns>
            <remarks>
            The EnumWindows function does not enumerate child windows, with the exception of a few top-level windows owned by the system that have the WS_CHILD style.
            This function is more reliable than calling the GetWindow function in a loop. An application that calls GetWindow to perform this task risks being caught in an infinite loop or referencing a handle to a window that has been destroyed. 
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.FillRect(System.Void*,JetBrains.Interop.WinApi.RECT*,System.Void*)">
            <summary>
            The FillRect function fills a rectangle by using the specified brush. This function includes the left and top borders, but excludes the right and bottom borders of the rectangle.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.FlashWindowEx(JetBrains.Interop.WinApi.Declarations.Structures.FLASHWINFO*)">
            <summary>
            The SetForegroundWindow function puts the thread that created the specified window into the foreground and
            activates the window. Keyboard input is directed to the window, and various visual cues are changed for the user.
            The system assigns a slightly higher priority to the thread that created the foreground window than it does to other threads.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetActiveWindow">
            <summary>
            The GetActiveWindow function retrieves the window handle to the active window attached to the calling thread's message queue. 
            </summary>
            <returns>The return value is the handle to the active window attached to the calling thread's message queue. Otherwise, the return value is NULL. </returns>
            <remarks>To get the handle to the foreground window, you can use GetForegroundWindow. Windows 98/Me and Windows NT 4.0 SP3 and later: To get the window handle to the active window in the message queue for another thread, use GetGUIThreadInfo.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetAncestor(System.Void*,System.UInt32)">
            <summary>
            The GetAncestor function retrieves the handle to the ancestor of the specified window. 
            </summary>
            <param name="hwnd">[in] Handle to the window whose ancestor is to be retrieved. If this parameter is the desktop window, the function returns <c>NULL</c>. </param>
            <param name="gaFlags">[in] Specifies the ancestor to be retrieved. This parameter can be one of the following values.</param>
            <returns>The return value is the handle to the ancestor window.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetClassNameW(System.Void*,System.Char*,System.Int32)">
            <summary>
            The GetClassName function retrieves the name of the class to which the specified window belongs. 
            </summary>
            <param name="hWnd">[in] Handle to the window and, indirectly, the class to which the window belongs. </param>
            <param name="lpClassName">[out] Pointer to the buffer that is to receive the class name string. </param>
            <param name="nMaxCount">[in] Specifies the length, in TCHAR, of the buffer pointed to by the lpClassName parameter. The class name string is truncated if it is longer than the buffer and is always null-terminated. </param>
            <returns>If the function succeeds, the return value is the number of TCHAR copied to the specified buffer. If the function fails, the return value is zero. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetClientRect(System.Void*,JetBrains.Interop.WinApi.RECT*)">
            <summary>
            The GetClientRect function retrieves the coordinates of a window's client area. The client coordinates specify the upper-left and lower-right corners of the client area. Because client coordinates are relative to the upper-left corner of a window's client area, the coordinates of the upper-left corner are (0,0). 
            </summary>
            <param name="hWnd">[in] Handle to the window whose client coordinates are to be retrieved. </param>
            <param name="lpRect">[out] Pointer to a RECT structure that receives the client coordinates. The left and top members are zero. The right and bottom members contain the width and height of the window. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
            <remarks>In conformance with conventions for the RECT structure, the bottom-right coordinates of the returned rectangle are exclusive. In other words, the pixel at (right, bottom) lies immediately outside the rectangle.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetCursorInfo(JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO*)">
            <summary>
            The GetCursorInfo function retrieves information about the global cursor.
            </summary>
            <param name="pci">Pointer to a CURSORINFO structure that receives the information. Note that you must set CURSORINFO.cbSize to sizeof(CURSORINFO) before calling this function.</param>
            <returns>If the function succeeds, the return value is nonzero. 
            If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetCursorPos(JetBrains.Interop.WinApi.POINT*)">
            <summary>
            Retrieves the cursor's position, in screen coordinates.
            </summary>
            <param name="lpPoint">[out] Pointer to a POINT structure that receives the screen coordinates of the cursor.</param>
            <returns>Returns nonzero if successful or zero otherwise. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetDlgItem(System.Void*,System.Int32)">
            <summary>
            The GetDlgItem function retrieves a handle to a control in the specified dialog box. 
            </summary>
            <param name="hDlg">[in] Handle to the dialog box that contains the control. </param>
            <param name="nIDDlgItem">[in] Specifies the identifier of the control to be retrieved.</param>
            <returns>If the function succeeds, the return value is the window handle of the specified control. 
            If the function fails, the return value is NULL, indicating an invalid dialog box handle or a nonexistent control. To get extended error information, call GetLastError.</returns>
            <remarks>You can use the GetDlgItem function with any parent-child window pair, not just with dialog boxes. As long as the hDlg parameter specifies a parent window and the child window has a unique identifier (as specified by the hMenu parameter in the CreateWindow or CreateWindowEx function that created the child window), GetDlgItem returns a valid handle to the child window.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetFocus">
            <summary>
            The GetFocus function retrieves the handle to the window that has the keyboard focus, if the window is attached to the calling thread's message queue. 
            </summary>
            <returns>The return value is the handle to the window with the keyboard focus. If the calling thread's message queue does not have an associated window with the keyboard focus, the return value is <c>NULL</c>.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetForegroundWindow">
            <summary>
            The GetForegroundWindow function returns a handle to the foreground window (the window with which the user is currently working). The system assigns a slightly higher priority to the thread that creates the foreground window than it does to other threads. 
            </summary>
            <returns>The return value is a handle to the foreground window. The foreground window can be NULL in certain circumstances, such as when a window is losing activation. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetGUIThreadInfo(System.UInt32,JetBrains.Interop.WinApi.GUITHREADINFO*)">
            <summary>
            Retrieves information about the active window or a specified graphical user interface (GUI) thread.
            </summary>
            <param name="idThread">Identifies the thread for which information is to be retrieved. To retrieve this value, use the GetWindowThreadProcessId function. If this parameter is NULL, the function returns information for the foreground thread.</param>
            <param name="lpgui">Pointer to a <see cref="T:JetBrains.Interop.WinApi.GUITHREADINFO"/> structure that receives information describing the thread. Note that you must set <c>GUITHREADINFO.cbSize</c> to <c>sizeof(GUITHREADINFO)</c> before calling this function.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
            <remarks>
            This function succeeds even if the active window is not owned by the calling process. If the specified thread does not exist or have an input queue, the function will fail. 
            This function is useful for retrieving out-of-context information about a thread. The information retrieved is the same as if an application retrieved the information about itself. 
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetKeyState(System.Int32)">
            <summary>
            The GetKeyState function retrieves the status of the specified virtual key. The status specifies whether the key is up, down, or toggled (on, off—alternating each time the key is pressed). 
            </summary>
            <param name="nVirtKey">
            [in] Specifies a virtual key. If the desired virtual key is a letter or digit (A through Z, a through z, or 0 through 9), nVirtKey must be set to the ASCII value of that character. For other keys, it must be a virtual-key code.
            If a non-English keyboard layout is used, virtual keys with values in the range ASCII A through Z and 0 through 9 are used to specify most of the character keys. For example, for the German keyboard layout, the virtual key of value ASCII O (0x4F) refers to the "o" key, whereas VK_OEM_1 refers to the "o with umlaut" key.
            </param>
            <returns>
            The return value specifies the status of the specified virtual key, as follows:
            • If the high-order bit is 1, the key is down; otherwise, it is up.
            • If the low-order bit is 1, the key is toggled. A key, such as the CAPS LOCK key, is toggled if it is turned on. The key is off and untoggled if the low-order bit is 0. A toggle key's indicator light (if any) on the keyboard will be on when the key is toggled, and off when the key is untoggled.
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetMessageW(JetBrains.Interop.WinApi.MSG*,System.Void*,System.UInt32,System.UInt32)">
            <summary>
            The GetMessage function retrieves a message from the calling thread's message queue. The function dispatches incoming sent messages until a posted message is available for retrieval. Unlike GetMessage, the <see cref="M:JetBrains.Interop.WinApi.User32Dll.PeekMessageW(JetBrains.Interop.WinApi.MSG*,System.Void*,System.UInt32,System.UInt32,System.UInt32)"/> function does not wait for a message to be posted before returning.
            </summary>
            <param name="lpMsg">[out] Pointer to an MSG structure that receives message information from the thread's message queue.</param>
            <param name="hWnd">[in] Handle to the window whose messages are to be retrieved. The window must belong to the current thread. If hWnd is NULL, GetMessage retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose hwnd value is NULL (see the MSG structure). Therefore if hWnd is NULL, both window messages and thread messages are processed. If hWnd is -1, GetMessage retrieves only messages on the current thread's message queue whose hwnd value is NULL, that is, thread messages as posted by PostMessage (when the hWnd parameter is NULL) or PostThreadMessage.</param>
            <param name="wMsgFilterMin">[in] Specifies the integer value of the lowest message value to be retrieved. Use WM_KEYFIRST to specify the first keyboard message or WM_MOUSEFIRST to specify the first mouse message. Windows XP: Use WM_INPUT here and in wMsgFilterMax to specify only the WM_INPUT messages. If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed).</param>
            <param name="wMsgFilterMax">[in] Specifies the integer value of the highest message value to be retrieved. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message. Windows XP: Use WM_INPUT here and in wMsgFilterMin to specify only the WM_INPUT messages. If wMsgFilterMin and wMsgFilterMax are both zero, GetMessage returns all available messages (that is, no range filtering is performed).</param>
            <returns>If the function retrieves a message other than WM_QUIT, the return value is nonzero. If the function retrieves the WM_QUIT message, the return value is zero. If there is an error, the return value is -1. For example, the function fails if hWnd is an invalid window handle or lpMsg is an invalid pointer. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetParent(System.Void*)">
            <summary>
            The GetParent function retrieves a handle to the specified window's parent or owner. To retrieve a handle to a specified ancestor, use the GetAncestor function.
            </summary>
            <param name="hWnd">[in] Handle to the window whose parent window handle is to be retrieved. </param>
            <returns>If the window is a child window, the return value is a handle to the parent window. If the window is a top-level window, the return value is a handle to the owner window. If the window is a top-level unowned window or if the function fails, the return value is NULL. To get extended error information, call GetLastError. For example, this would determine, when the function returns NULL, if the function failed or the window was a top-level window.</returns>
            <remarks>Note that, despite its name, this function can return an owner window instead of a parent window. To obtain the parent window and not the owner, use GetAncestor with the GA_PARENT flag.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetSystemMetrics(System.Int32)">
            <summary>
            Retrieves the specified system metric or system configuration setting.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetThreadDesktop(System.UInt32)">
            <summary>
            Retrieves a handle to the desktop assigned to the specified thread. Windows Me/98/95:  The system does not support multiple desktops, so GetThreadDesktop always returns the same value.
            </summary>
            <param name="dwThreadId">A handle to the thread. The GetCurrentThreadId and CreateProcess functions return thread identifiers.</param>
            <returns>If the function succeeds, the return value is a handle to the desktop associated with the specified thread. You do not need to call the CloseDesktop function to close the returned handle. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetWindowLongPtrW(System.Void*,System.Int32)">
            <summary>
            The GetWindowLongPtrW function retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetWindowRect(System.Void*,JetBrains.Interop.WinApi.RECT*)">
            <summary>
            The <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetWindowRect(System.Void*,JetBrains.Interop.WinApi.RECT*)"/> function retrieves the dimensions of the bounding rectangle of the specified window. The dimensions are given in screen coordinates that are relative to the upper-left corner of the screen.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetWindowTextW(System.Void*,System.Char*,System.Int32)">
            <summary>
            The GetWindowText function copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application.
            </summary>
            <param name="hWnd">[in] Handle to the window or control containing the text. </param>
            <param name="lpString">[out] Pointer to the buffer that will receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated with a NULL character</param>
            <param name="nMaxCount">[in] Specifies the maximum number of characters to copy to the buffer, including the NULL character. If the text exceeds this limit, it is truncated.</param>
            <returns>If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating NULL character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call GetLastError. This function cannot retrieve the text of an edit control in another application.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.GetWindowThreadProcessId(System.Void*,System.UInt32*)">
            <summary>
            The GetWindowThreadProcessId function retrieves the identifier of the thread that created the specified window and, optionally, the identifier of the process that created the window.
            </summary>
            <param name="hWnd">[in] Handle to the window. </param>
            <param name="lpdwProcessId">[out] Pointer to a variable that receives the process identifier. If this parameter is not NULL, GetWindowThreadProcessId copies the identifier of the process to the variable; otherwise, it does not. </param>
            <returns>The return value is the identifier of the thread that created the window. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.InvalidateRect(System.Void*,JetBrains.Interop.WinApi.RECT*,System.Int32)">
            <summary>
            The InvalidateRect function adds a rectangle to the specified window's update region. The update region represents the portion of the window's client area that must be redrawn. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsChild(System.Void*,System.Void*)">
            <summary>
            The IsChild function tests whether a window is a child window or descendant window of a specified parent window. A child window is the direct descendant of a specified parent window if that parent window is in the chain of parent windows; the chain of parent windows leads from the original overlapped or pop-up window to the child window. 
            </summary>
            <param name="hWndParent">[in] Handle to the parent window. </param>
            <param name="hWnd">[in] Handle to the window to be tested. </param>
            <returns>If the window is a child or descendant window of the specified parent window, the return value is nonzero. If the window is not a child or descendant window of the specified parent window, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsIconic(System.Void*)">
            <summary>
            The IsIconic function return true is windows is minimized. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsWindow(System.Void*)">
            <summary>
            The IsWindow function determines whether the specified window handle identifies an existing window.
            </summary>
            <param name="hWnd">[in] Handle to the window to test.</param>
            <returns>If the window handle identifies an existing window, the return value is nonzero. If the window handle does not identify an existing window, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsWindowEnabled(System.Void*)">
            <summary>
            The IsWindowEnabled function determines whether the specified window is enabled for mouse and keyboard input. 
            </summary>
            <param name="hWnd">[in] Handle to the window to test.</param>
            <returns>If the window is enabled, the return value is nonzero. If the window is not enabled, the return value is zero.</returns>
            <remarks>A child window receives input only if it is both enabled and visible.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsWindowVisible(System.Void*)">
            <summary>
            The IsWindowVisible function retrieves the visibility state of the specified window.
            </summary>
            <param name="hWnd">[in] Handle to the window to test.</param>
            <returns>If the specified window, its parent window, its parent's parent window, and so forth, have the WS_VISIBLE style, the return value is nonzero. Otherwise, the return value is zero. Because the return value specifies whether the window has the WS_VISIBLE style, it may be nonzero even if the window is totally obscured by other windows.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.IsZoomed(System.Void*)">
            <summary>
            The IsZoomed function return true is windows is maximized. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.LoadCursorW(System.Void*,System.Char*)">
            <summary>
            The LoadCursor function loads the specified cursor resource from the executable (.EXE) file associated with an application instance.
            </summary>
            <param name="hInstance">[in] Handle to an instance of the module whose executable file contains the cursor to be loaded.</param>
            <param name="lpCursorName">[in] Pointer to a null-terminated string that contains the name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The MAKEINTRESOURCE macro can also be used to create this value. To use one of the predefined cursors, the application must set the hInstance parameter to NULL and the lpCursorName parameter to one the following values: <see cref="T:JetBrains.Interop.WinApi.StockCursors"/></param>
            <returns>If the function succeeds, the return value is the handle to the newly loaded cursor.
            If the function fails, the return value is NULL. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.LoadStringW(System.Void*,System.UInt32,System.UInt16*,System.Int32)">
            <summary>
            The LoadString function loads a string resource from the executable file associated with a specified module, copies the string into a buffer, and appends a terminating NULL character. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.MapWindowPoints(System.Void*,System.Void*,JetBrains.Interop.WinApi.POINT*,System.UInt32)">
             <summary>
             The MapWindowPoints function converts (maps) a set of points from a coordinate space relative to one window to a coordinate space relative to another window. 
             </summary>
             <param name="hWndFrom">[in] Handle to the window from which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are presumed to be in screen coordinates. </param>
             <param name="hWndTo">[in] Handle to the window to which points are converted. If this parameter is NULL or HWND_DESKTOP, the points are converted to screen coordinates. </param>
             <param name="lpPoints">[in/out] Pointer to an array of POINT structures that contain the set of points to be converted. The points are in device units. This parameter can also point to a RECT structure, in which case the cPoints parameter should be set to 2. </param>
             <param name="cPoints">[in] Specifies the number of POINT structures in the array pointed to by the lpPoints parameter. </param>
             <returns>If the function succeeds, the low-order word of the return value is the number of pixels added to the horizontal coordinate of each source point in order to compute the horizontal coordinate of each destination point; the high-order word is the number of pixels added to the vertical coordinate of each source point in order to compute the vertical coordinate of each destination point. If the function fails, the return value is zero. Call SetLastError prior to calling this method to differentiate an error return value from a legitimate "0" return value.  Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
             <remarks>If hWndFrom or hWndTo (or both) are mirrored windows (that is, have WS_EX_LAYOUTRTL extended style), MapWindowPoints will automatically adjust mirrored coordinates if you pass two or less points in lpPoints. If you pass more than two points, the function will not fail but it will return erroneous positions. Thus, to guarantee the correct transformation of rectangle coordinates, you must call MapWindowPoints with two or less points at a time, as shown in the following example:
             <code>
               RECT        rc[10];
            
               for(int i =0; i &lt; (sizeof(rc)/sizeof(rc[0])); i++)
               {
                   MapWindowPoints(hWnd1, hWnd2, (LPPOINT)(&amp;rc[i]), (sizeof(RECT)/sizeof(POINT)) );
               }
             </code></remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.MessageBoxW(System.Void*,System.String,System.String,System.UInt32)">
            <summary>
            The MessageBox function creates, displays, and operates a message box. The message box contains an application-defined message and title, along with any combination of predefined icons and push buttons.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.MsgWaitForMultipleObjects(System.UInt32,System.Void**,System.Int32,System.UInt32,System.UInt32)">
            <summary>
            Waits until one or all of the specified objects are in the signaled state or the time-out interval elapses. The objects can include input event objects, which you specify using the dwWakeMask parameter. To enter an alertable wait state, use the <see cref="M:JetBrains.Interop.WinApi.User32Dll.MsgWaitForMultipleObjectsEx(System.UInt32,System.Void**,System.UInt32,System.UInt32,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.MsgWaitForMultipleObjectsEx(System.UInt32,System.Void**,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Waits until one or all of the specified objects are in the signaled state, an I/O completion routine or asynchronous procedure call (APC) is queued to the thread, or the time-out interval elapses. The array of objects can include input event objects, which you specify using the dwWakeMask parameter.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.OpenDesktopW(System.String,System.UInt32,System.Int32,System.UInt32)">
            <summary>
            Opens the specified desktop object.
            </summary>
            <param name="lpszDesktop">The name of the desktop to be opened. Desktop names are case-insensitive. This desktop must belong to the current window station.</param>
            <param name="dwFlags">This parameter can be zero or the following value. <c>DF_ALLOWOTHERACCOUNTHOOK</c> <c>0x0001</c> Allows processes running in other accounts on the desktop to set hooks in this process.</param>
            <param name="fInherit">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
            <param name="dwDesiredAccess">The access to the desktop. For a list of access rights, see Desktop Security and Access Rights.</param>
            <returns>If the function succeeds, the return value is a handle to the opened desktop. When you are finished using the handle, call the CloseDesktop function to close it. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.OpenWindowStationW(System.String,System.Int32,System.UInt32)">
            <summary>
            Opens the specified window station.
            </summary>
            <param name="lpszWinSta">The name of the window station to be opened. Window station names are case-insensitive. This window station must belong to the current session.</param>
            <param name="fInherit">If this value is TRUE, processes created by this process will inherit the handle. Otherwise, the processes do not inherit this handle.</param>
            <param name="dwDesiredAccess">The access to the window station. For a list of access rights, see Window Station Security and Access Rights.</param>
            <returns>If the function succeeds, the return value is the handle to the specified window station. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.PeekMessageW(JetBrains.Interop.WinApi.MSG*,System.Void*,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            The PeekMessage function dispatches incoming sent messages, checks the thread message queue for a posted message, and retrieves the message (if any exist).
            </summary>
            <param name="lpMsg">[out] Pointer to an MSG structure that receives message information.</param>
            <param name="hWnd">[in] Handle to the window whose messages are to be retrieved. The window must belong to the current thread. 
            If hWnd is NULL, PeekMessage retrieves messages for any window that belongs to the current thread, and any messages on the current thread's message queue whose hwnd value is NULL (see the MSG structure). Therefore if hWnd is NULL, both window messages and thread messages are processed.
            If hWnd is -1, PeekMessage retrieves only messages on the current thread's message queue whose hwnd value is NULL, that is, thread messages as posted by PostMessage (when the hWnd parameter is NULL) or PostThreadMessage.
            </param>
            <param name="wMsgFilterMin">[in] Specifies the value of the first message in the range of messages to be examined. Use WM_KEYFIRST to specify the first keyboard message or WM_MOUSEFIRST to specify the first mouse message. If wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed).</param>
            <param name="wMsgFilterMax">[in] Specifies the value of the last message in the range of messages to be examined. Use WM_KEYLAST to specify the last keyboard message or WM_MOUSELAST to specify the last mouse message. If wMsgFilterMin and wMsgFilterMax are both zero, PeekMessage returns all available messages (that is, no range filtering is performed).</param>
            <param name="wRemoveMsg">[in] Specifies how messages are handled. This parameter can be one of the following values. PM_NOREMOVE Messages are not removed from the queue after processing by PeekMessage. PM_REMOVE Messages are removed from the queue after processing by PeekMessage. You can optionally combine the value PM_NOYIELD with either PM_NOREMOVE or PM_REMOVE. This flag prevents the system from releasing any thread that is waiting for the caller to go idle (see WaitForInputIdle). By default, all message types are processed. To specify that only certain message should be processed, specify one or more of the following values. PM_QS_INPUT Windows 98/Me, Windows 2000/XP: Process mouse and keyboard messages. PM_QS_PAINT Windows 98/Me, Windows 2000/XP: Process paint messages. PM_QS_POSTMESSAGE Windows 98/Me, Windows 2000/XP: Process all posted messages, including timers and hotkeys.  PM_QS_SENDMESSAGE Windows 98/Me, Windows 2000/XP: Process all sent messages.</param>
            <returns>If a message is available, the return value is nonzero. If no messages are available, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.PostMessageW(System.Void*,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            The PostMessageW function places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message. To post a message in the message queue associate with a thread, use the PostThreadMessage function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.PostThreadMessageW(System.UInt32,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            The PostThreadMessage function posts a message to the message queue of the specified thread. It returns without waiting for the thread to process the message.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.PrintWindow(System.Void*,System.Void*,System.UInt32)">
            <summary>
            The PrintWindow function copies a visual window into the specified device context (DC), typically a printer DC.
            </summary>
            <param name="hwnd">Window to copy</param>
            <param name="hdcBlt">HDC to print into</param>
            <param name="nFlags">Optional flags</param>
            <returns>If the function succeeds, it returns a nonzero value.
            If the function fails, it returns zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ScreenToClient(System.Void*,JetBrains.Interop.WinApi.POINT*)">
            <summary>
            The ScreenToClient function converts the screen coordinates of a specified point on the screen to client-area coordinates. 
            </summary>
            <param name="hWnd">[in] Handle to the window whose client area will be used for the conversion. </param>
            <param name="lpPoint">[in] Pointer to a POINT structure that specifies the screen coordinates to be converted. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SendMessageW(System.Void*,System.UInt32,System.IntPtr,System.IntPtr)">
            <summary>
            The SendMessage function sends the specified message to a window or windows. It calls the window procedure for the specified window and does not return until the window procedure has processed the message.
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a thread's message queue and return immediately, use the PostMessageW or PostThreadMessage function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetActiveWindow(System.Void*)">
            <summary>
            The SetActiveWindow function activates a window. The window must be attached to the calling thread's message queue. 
            </summary>
            <param name="hWnd">[in] Handle to the top-level window to be activated.</param>
            <returns>If the function succeeds, the return value is the handle to the window that was previously active. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
            <remarks>
            <para>The SetActiveWindow function activates a window, but not if the application is in the background. The window will be brought into the foreground (top of Z-Order) if its application is in the foreground when the system activates the window. </para>
            <para>If the window identified by the hWnd parameter was created by the calling thread, the active window status of the calling thread is set to hWnd. Otherwise, the active window status of the calling thread is set to NULL.</para>
            <para>By using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call SetActiveWindow to activate a window attached to another thread's message queue. </para>
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetCursor(System.Void*)">
            <summary>
            The SetCursor function sets the cursor shape. 
            </summary>
            <param name="hCursor">
            [in] 
            Handle to the cursor. The cursor must have been created by the CreateCursor function or loaded by the LoadCursor or LoadImage function. If this parameter is NULL, the cursor is removed from the screen.
            Windows 95/98/Me: The width and height of the cursor must be the values returned by the GetSystemMetrics function for SM_CXCURSOR and SM_CYCURSOR. For Microsoft Windows 95, either the cursor bit depth must match the bit depth of the display or the cursor must be monochrome. However, for Windows 98 and Windows 98, if the cursor bit depth does not match the bit depth of the display then the cursor is converted to 4bpp VGA color. 
            </param>
            <returns>
            The return value is the handle to the previous cursor, if there was one. 
            If there was no previous cursor, the return value is NULL. 
            </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetFocus(System.Void*)">
            <summary>
            The SetFocus function sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue. The SetFocus function sends a WM_KILLFOCUS message to the window that loses the keyboard focus and a WM_SETFOCUS message to the window that receives the keyboard focus. It also activates either the window that receives the focus or the parent of the window that receives the focus. If a window is active but does not have the focus, any key pressed will produce the WM_SYSCHAR, WM_SYSKEYDOWN, or WM_SYSKEYUP message. If the VK_MENU key is also pressed, the lParam parameter of the message will have bit 30 set. Otherwise, the messages produced do not have this bit set. By using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call SetFocus to set the keyboard focus to a window attached to another thread's message queue. 
            </summary>
            <param name="hWnd">[in] Handle to the window that will receive the keyboard input. If this parameter is NULL, keystrokes are ignored. </param>
            <returns>If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the hWnd parameter is invalid or the window is not attached to the calling thread's message queue, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetForegroundWindow(System.Void*)">
            <summary>
            The SetForegroundWindow function puts the thread that created the specified window into the foreground and
            activates the window. Keyboard input is directed to the window, and various visual cues are changed for the user.
            The system assigns a slightly higher priority to the thread that created the foreground window than it does to other threads.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetLayeredWindowAttributes(System.Void*,System.UInt32,System.Byte,System.UInt32)">
            <summary>
            The SetLayeredWindowAttributes function sets the opacity and transparency color key of a layered window.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetParent(System.Void*,System.Void*)">
            <summary>
            The SetParent function changes the parent window of the specified child window. 
            An application can use the SetParent function to set the parent window of a pop-up, overlapped, or child window. The new parent window and the child window must belong to the same application. If the window identified by the hWndChild parameter is visible, the system performs the appropriate redrawing and repainting. For compatibility reasons, SetParent does not modify the WS_CHILD or WS_POPUP window styles of the window whose parent is being changed. Therefore, if hWndNewParent is NULL, you should also clear the WS_CHILD bit and set the WS_POPUP style after calling SetParent. Conversely, if hWndNewParent is not NULL and the window was previously a child of the desktop, you should clear the WS_POPUP style and set the WS_CHILD style before calling SetParent. Windows 2000/XP: When you change the parent of a window, you should synchronize the UISTATE of both windows. For more information, see WM_CHANGEUISTATE and WM_UPDATEUISTATE. 
            </summary>
            <param name="hWndChild">[in] Handle to the child window.</param>
            <param name="hWndNewParent">[in] Handle to the new parent window. If this parameter is NULL, the desktop window becomes the new parent window. Windows 2000/XP: If this parameter is HWND_MESSAGE, the child window becomes a message-only window.</param>
            <returns>If the function succeeds, the return value is a handle to the previous parent window. If the function fails, the return value is NULL. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetProcessWindowStation(System.Void*)">
            <summary>
            Assigns the specified window station to the calling process. This enables the process to access objects in the window station such as desktops, the clipboard, and global atoms. All subsequent operations on the window station use the access rights granted to hWinSta.
            </summary>
            <param name="hWinSta">A handle to the window station. This can be a handle returned by the CreateWindowStation, OpenWindowStation, or GetProcessWindowStation function. This window station must be associated with the current session.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetThreadDesktop(System.Void*)">
            <summary>
            Assigns the specified desktop to the calling thread. All subsequent operations on the desktop use the access rights granted to the desktop.
            </summary>
            <param name="hDesktop">A handle to the desktop to be assigned to the calling thread. This handle is returned by the CreateDesktop, GetThreadDesktop, OpenDesktop, or OpenInputDesktop function. This desktop must be associated with the current window station for the process.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SetWindowLongPtrW(System.Void*,System.Int32,System.IntPtr)">
            <summary>
            The SetWindowLongPtrW function changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ShowWindow(System.Void*,System.Int32)">
            <summary>
            The ShowWindow function sets the specified window's show state. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.SwitchToThisWindow(System.Void*,System.UInt32)">
            <summary>
            The SwitchToThisWindow function is called to switch focus to a specified window and bring it to the foreground.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.TranslateMessage(JetBrains.Interop.WinApi.MSG*)">
            <summary>
            The TranslateMessage function translates virtual-key messages into character messages. The character messages are posted to the calling thread's message queue, to be read the next time the thread calls the <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetMessageW(JetBrains.Interop.WinApi.MSG*,System.Void*,System.UInt32,System.UInt32)"/> or <see cref="M:JetBrains.Interop.WinApi.User32Dll.PeekMessageW(JetBrains.Interop.WinApi.MSG*,System.Void*,System.UInt32,System.UInt32,System.UInt32)"/> function.
            </summary>
            <param name="lpMsg">[in] Pointer to an <see cref="T:JetBrains.Interop.WinApi.MSG"/> structure that contains message information retrieved from the calling thread's message queue by using the GetMessage or PeekMessage function.</param>
            <returns>If the message is translated (that is, a character message is posted to the thread's message queue), the return value is nonzero. If the message is <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_KEYDOWN"/>, <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_KEYUP"/>, <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_SYSKEYDOWN"/>, or <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.WM_SYSKEYUP"/>, the return value is nonzero, regardless of the translation. If the message is not translated (that is, a character message is not posted to the thread's message queue), the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.UpdateLayeredWindow(System.Void*,System.Void*,JetBrains.Interop.WinApi.POINT*,JetBrains.Interop.WinApi.Declarations.Structures.SIZE*,System.Void*,JetBrains.Interop.WinApi.POINT*,System.UInt32,JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION*,System.UInt32)">
            <summary>
            The UpdateLayeredWindow function updates the position, size, shape, content, and translucency of a layered window.
            </summary>
            <param name="hwnd">[in] Handle to a layered window. A layered window is created by specifying WS_EX_LAYERED when creating the window with the CreateWindowEx function.</param>
            <param name="hdcDst">[in] 
            Handle to a device context (DC) for the screen. This handle is obtained by specifying NULL when calling the function. It is used for palette color matching when the window contents are updated. If hdcDst isNULL, the default palette will be used.
            If hdcSrc is NULL, hdcDst must be NULL.</param>
            <param name="pptDst">[in] Pointer to a POINT structure that specifies the new screen position of the layered window. If the current position is not changing, pptDst can be NULL. </param>
            <param name="psize">[in] Pointer to a SIZE structure that specifies the new size of the layered window. If the size of the window is not changing, psize can be NULL. If hdcSrc is NULL, psize must be NULL.</param>
            <param name="hdcSrc">[in] Handle to a DC for the surface that defines the layered window. This handle can be obtained by calling the CreateCompatibleDC function. If the shape and visual context of the window are not changing, hdcSrc can be NULL.</param>
            <param name="pptSrc">[in] Pointer to a POINT structure that specifies the location of the layer in the device context. If hdcSrc is NULL, pptSrc should be NULL.</param>
            <param name="crKey">[in] Pointer to a COLORREF value that specifies the color key to be used when composing the layered window. To generate a COLORREF, use the RGB macro.</param>
            <param name="pblend">[in] Pointer to a BLENDFUNCTION structure that specifies the transparency value to be used when composing the layered window.</param>
            <param name="dwFlags">[in] This parameter can be one of the following values. <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_ALPHA"/>, <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_COLORKEY"/>, <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_OPAQUE"/>. If hdcSrc is NULL, dwFlags should be zero.</param>
            <returns>If the function succeeds, the return value is nonzero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.ValidateRect(System.Void*,JetBrains.Interop.WinApi.RECT*)">
            <summary>
            The ValidateRect function validates the client area within a rectangle by removing the rectangle from the update region of the specified window.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.WindowFromPoint(JetBrains.Interop.WinApi.POINT)">
            <summary>
            <para>The WindowFromPoint function retrieves a handle to the window that contains the specified point. </para>
            </summary>
            <param name="Point">[in] Specifies a POINT structure that defines the point to be checked. </param>
            <returns>The return value is a handle to the window that contains the point. If no window exists at the given point, the return value is NULL. If the point is over a static text control, the return value is a handle to the window under the static text control. </returns>
            <remarks>The WindowFromPoint function does not retrieve a handle to a hidden or disabled window, even if the point is within the window. An application should use the ChildWindowFromPoint function for a nonrestrictive search.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.BringWindowToTop(System.IntPtr)">
            <summary>
            The BringWindowToTop function brings the specified window to the top of the Z order. If the window is a top-level
            window, it is activated. If the window is a child window, the top-level parent window associated with the child window is activated.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.ClientToScreen(System.IntPtr,System.Drawing.Point)">
            <summary>
            Converts a point from window coordinates to screen coordinates, returns an empty point on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.ClientToScreen(System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Converts a rectangle from window coordinates to screen coordinates, returns an empty rectangle on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.DestroyWindow(System.IntPtr)">
            <summary>
            Calls <see cref="M:JetBrains.Interop.WinApi.User32Dll.DestroyWindow(System.Void*)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.DisableWindow(System.IntPtr)">
            <summary>
            Disables the window given by its handle.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.EnableWindow(System.IntPtr)">
            <summary>
            Enables the window given by its handle.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetChildWindowHandles(System.IntPtr)">
            <summary>
            Lists the handles of all child windows of a specific window, recursively.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetClientRect(System.IntPtr)">
            <summary>
            Gets the client rectangle for the window.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetCursorInfo">
            <summary>
            Gets the point out of the <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetCursorInfo(JetBrains.Interop.WinApi.Declarations.Structures.CURSORINFO*)"/> (note: <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetCursorPos(JetBrains.Interop.WinApi.POINT*)"/> should not be used).
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetDlgItem(System.IntPtr,System.Int32)">
            <summary>
            The GetDlgItem function retrieves a handle to a control in the specified dialog box. 
            </summary>
            <param name="hDlg">[in] Handle to the dialog box that contains the control. </param>
            <param name="nIDDlgItem">[in] Specifies the identifier of the control to be retrieved.</param>
            <returns>If the function succeeds, the return value is the window handle of the specified control. 
            If the function fails, the return value is NULL, indicating an invalid dialog box handle or a nonexistent control. To get extended error information, call GetLastError.</returns>
            <remarks>You can use the GetDlgItem function with any parent-child window pair, not just with dialog boxes. As long as the hDlg parameter specifies a parent window and the child window has a unique identifier (as specified by the hMenu parameter in the CreateWindow or CreateWindowEx function that created the child window), GetDlgItem returns a valid handle to the child window.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetFocusOnAnyThreadInAnyProcess">
            <summary>
            Gets the window that currently has focus on this desktop — any thread, any process, etc.
            </summary>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.GetFocus"/>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.GetForegroundWindow"/>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetFocusOnAnyThreadInOurProcess"/>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetFocusOnAnyThreadInOurProcess">
            <summary>
            Gets the window that currently has focus in our process — but on any thread, unlike <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetFocus"/>.
            </summary>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.GetFocus"/>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.GetForegroundWindow"/>
            <seealso cref="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetFocusOnAnyThreadInAnyProcess"/>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetParent(System.IntPtr)">
            <summary>
            Gets parent window for the window
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetThreadTopLevelWindowHandles(System.UInt32)">
            <summary>
            Lists the handles of all the top-level windows that belong to the specific thread.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetTopLevelWindowHandles">
            <summary>
            Lists the handles of all the top-level windows currently available in the system.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowClassName(System.IntPtr)">
            <summary>
            Wnd class name.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowProcessId(System.IntPtr)">
            <summary>
            Gets the ID of the process that owns the window.
            Note that creating a <see cref="T:System.Diagnostics.Process"/> wrapper for that is very expensive because it causes an enumeration of all the system processes to happen.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowRect(System.IntPtr)">
            <summary>
            Wraps <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetWindowRect(System.Void*,JetBrains.Interop.WinApi.RECT*)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowText(System.IntPtr)">
            <summary>
            Wnd text.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.GetWindowThreadId(System.IntPtr)">
            <summary>
            Gets the ID of the thread that owns the window.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.InvalidateRect(System.IntPtr,System.Nullable{System.Drawing.Rectangle},System.Boolean)">
            <summary>
            Invalidates the specific rectangle. If <paramref name="rect"/> is <c>Null</c>, the whole window is invalidated.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsIconic(System.IntPtr)">
            <summary>
            The IsIconic function return true is windows is minimized. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsThreadWithMessageQueue(System.UInt32)">
            <summary>
            Gets whether the given thread has a message pump created for it.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsWindow(System.IntPtr)">
            <summary>
            The IsWindow function determines whether the specified window handle identifies an existing window.
            </summary>
            <param name="handle">[in] Handle to the window to test.</param>
            <returns>If the window handle identifies an existing window, the return value is nonzero. If the window handle does not identify an existing window, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsWindowEnabled(System.IntPtr)">
            <summary>
            The IsWindowEnabled function determines whether the specified window is enabled for mouse and keyboard input. 
            </summary>
            <param name="handle">[in] Handle to the window to test.</param>
            <returns>If the window is enabled, the return value is nonzero. If the window is not enabled, the return value is zero.</returns>
            <remarks>A child window receives input only if it is both enabled and visible.</remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsWindowVisible(System.IntPtr)">
            <summary>
            The IsWindowVisible function retrieves the visibility state of the specified window.
            </summary>
            <param name="handle">[in] Handle to the window to test.</param>
            <returns>If the specified window, its parent window, its parent's parent window, and so forth, have the WS_VISIBLE style, the return value is nonzero. Otherwise, the return value is zero. Because the return value specifies whether the window has the WS_VISIBLE style, it may be nonzero even if the window is totally obscured by other windows.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.IsZoomed(System.IntPtr)">
            <summary>
            The IsZoomed function return true is windows is maximized. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.PostMessage(System.IntPtr,JetBrains.Interop.WinApi.WindowsMessages,System.IntPtr,System.IntPtr)">
            <summary>
            The PostMessageW function places (posts) a message in the message queue associated with the thread that created the specified window and returns without waiting for the thread to process the message.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.ScreenToClient(System.IntPtr,System.Drawing.Point)">
            <summary>
            Converts a point from screen coordinates to window coordinates, returns an empty point on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.ScreenToClient(System.IntPtr,System.Drawing.Rectangle)">
            <summary>
            Converts a rectangle from screen coordinates to window coordinates, returns an empty rectangle on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SendMessageW(System.IntPtr,JetBrains.Interop.WinApi.WindowsMessages,System.IntPtr,System.IntPtr)">
            <summary>
            The SendMessage function sends the specified message to a window or windows. It calls the window procedure for the specified window and does not return until the window procedure has processed the message.
            To send a message and return immediately, use the SendMessageCallback or SendNotifyMessage function. To post a message to a thread's message queue and return immediately, use the PostMessageW or PostThreadMessage function.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetActiveWindow(System.IntPtr)">
            <summary>
            The SetActiveWindow function activates a window. The window must be attached to the calling thread's message queue. 
            </summary>
            <param name="hWnd">[in] Handle to the top-level window to be activated.</param>
            <returns>If the function succeeds, the return value is the handle to the window that was previously active. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
            <remarks>
            <para>The SetActiveWindow function activates a window, but not if the application is in the background. The window will be brought into the foreground (top of Z-Order) if its application is in the foreground when the system activates the window. </para>
            <para>If the window identified by the hWnd parameter was created by the calling thread, the active window status of the calling thread is set to hWnd. Otherwise, the active window status of the calling thread is set to NULL.</para>
            <para>By using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call SetActiveWindow to activate a window attached to another thread's message queue. </para>
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetFocus(System.IntPtr)">
            <summary>
            The SetFocus function sets the keyboard focus to the specified window. The window must be attached to the calling thread's message queue. The SetFocus function sends a WM_KILLFOCUS message to the window that loses the keyboard focus and a WM_SETFOCUS message to the window that receives the keyboard focus. It also activates either the window that receives the focus or the parent of the window that receives the focus. If a window is active but does not have the focus, any key pressed will produce the WM_SYSCHAR, WM_SYSKEYDOWN, or WM_SYSKEYUP message. If the VK_MENU key is also pressed, the lParam parameter of the message will have bit 30 set. Otherwise, the messages produced do not have this bit set. By using the AttachThreadInput function, a thread can attach its input processing to another thread. This allows a thread to call SetFocus to set the keyboard focus to a window attached to another thread's message queue. 
            </summary>
            <param name="hWnd">[in] Handle to the window that will receive the keyboard input. If this parameter is NULL, keystrokes are ignored. </param>
            <returns>If the function succeeds, the return value is the handle to the window that previously had the keyboard focus. If the hWnd parameter is invalid or the window is not attached to the calling thread's message queue, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetForegroundWindow(System.IntPtr)">
            <summary>
            The SetForegroundWindow function puts the thread that created the specified window into the foreground and
            activates the window. Keyboard input is directed to the window, and various visual cues are changed for the user.
            The system assigns a slightly higher priority to the thread that created the foreground window than it does to other threads.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetLayeredWindowAttributes(System.Windows.Forms.IWin32Window,System.Drawing.Color,System.Double,JetBrains.Interop.WinApi.SetLayeredWindowAttributesFlags)">
            <summary>
            Wraps the <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetLayeredWindowAttributes(System.Void*,System.UInt32,System.Byte,System.UInt32)"/> calls.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetWindowExStyle(System.Windows.Forms.IWin32Window,JetBrains.Interop.WinApi.WindowExStyles,System.Boolean)">
            <summary>
            Adds or removes window style bits given by the <paramref name="style"/> parameter (see WS_… in <see cref="T:JetBrains.UI.Interop.Win32Declarations"/>), depending on the <paramref name="set"/> value.
            </summary>
            <returns>Whether the operation succeeded.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetWindowExStyle(System.Void*,JetBrains.Interop.WinApi.WindowExStyles,System.Boolean)">
            <summary>
            Adds or removes window style bits given by the <paramref name="style"/> parameter (see WS_… in <see cref="T:JetBrains.UI.Interop.Win32Declarations"/>), depending on the <paramref name="set"/> value.
            </summary>
            <returns>Whether the operation succeeded.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetWindowStyle(System.Windows.Forms.IWin32Window,JetBrains.Interop.WinApi.WindowStyles,System.Boolean)">
            <summary>
            Adds or removes window style bits given by the <paramref name="style"/> parameter (see WS_… in <see cref="T:JetBrains.UI.Interop.Win32Declarations"/>), depending on the <paramref name="set"/> value.
            </summary>
            <returns>Whether the operation succeeded.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetWindowStyle(System.Void*,JetBrains.Interop.WinApi.WindowStyles,System.Boolean)">
            <summary>
            Adds or removes window style bits given by the <paramref name="style"/> parameter (see WS_… in <see cref="T:JetBrains.UI.Interop.Win32Declarations"/>), depending on the <paramref name="set"/> value.
            </summary>
            <returns>Whether the operation succeeded.</returns>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SetWindowStyleRaw(System.Void*,System.UInt32,JetBrains.Interop.WinApi.WindowLongPtrIndex,System.Boolean)">
            <summary>
            Raw implementation for setting a window style.
            </summary>
            <param name="hwnd">Handle to the window whose style is being set/reset.</param>
            <param name="style">One or more styles.</param>
            <param name="index">Index telling whether it would be simple style or extended style.</param>
            <param name="set">Whether to set or reset the style.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.ShowWindow(System.IntPtr,JetBrains.Interop.WinApi.ShowWindowCommands)">
            <summary>
            The ShowWindow function sets the specified window's show state. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.SwitchToThisWindow(System.IntPtr,System.Boolean)">
            <summary>
            The SwitchToThisWindow function is called to switch focus to a specified window and bring it to the foreground.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.TryGetWindowClassName(System.IntPtr)">
            <summary>
            Wnd class name. Throws no exceptions, returns <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Helpers.TryLoadStringResource(System.String,System.UInt32)">
            <summary>
            Loads a Win32 string resource from a native DLL.
            Returns <c>Null</c> on errors.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.User32Dll.Helpers.EnumWindowsProc">
            <summary>
            The EnumWindowsProc function is an application-defined callback function used with the EnumWindows or EnumDesktopWindows function. It receives top-level window handles. The WNDENUMPROC type defines a pointer to this callback function. EnumWindowsProc is a placeholder for the application-defined function name. 
            </summary>
            <param name="hwnd">[in] Handle to a top-level window. </param>
            <param name="lParam">[in] Specifies the application-defined value given in EnumWindows or EnumDesktopWindows. </param>
            <returns>To continue enumeration, the callback function must return TRUE; to stop enumeration, it must return FALSE.</returns>
            <remarks>An application must register this callback function by passing its address to EnumWindows or EnumDesktopWindows. </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Only32Bit.GetWindowLongPtrW(System.Void*,System.Int32)">
            <summary>
            The GetWindowLongPtrW function retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Only32Bit.SetWindowLongPtrW(System.Void*,System.Int32,System.IntPtr)">
            <summary>
            The SetWindowLongPtrW function changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Only64Bit.GetWindowLongPtrW(System.Void*,System.Int32)">
            <summary>
            The GetWindowLongPtrW function retrieves information about the specified window. The function also retrieves the value at a specified offset into the extra window memory.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.User32Dll.Only64Bit.SetWindowLongPtrW(System.Void*,System.Int32,System.IntPtr)">
            <summary>
            The SetWindowLongPtrW function changes an attribute of the specified window. The function also sets a value at the specified offset in the extra window memory.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.UxThemeDll">
            <summary>
            Declarations for the UxTheme.Dll.
            Must be 64bit-compatible.
            </summary>
            <remarks>
            IMPORTANT! Rules for authoring the class (v1.1):
            (1) All the function declarations MUST be 64-bit aware.
            (2) When copypasting from older declarations, you MUST check against the MSDN help or header declaration, 
               and you MUST ensure that each parameter has a proper size.
            (3) Call the Wide version of the functions (UCS-2-LE) unless there's a strong reason for calling the ANSI version 
               (such a reason MUST be indicated in XmlDoc). <c>CharSet = CharSet.Unicode</c>.
            (4) ExactSpelling MUST be TRUE. Add the "…W" suffix wherever needed.
            (5) SetLastError SHOULD be considered individually for each function. Setting it to <c>True</c> allows to report the errors,
               but slows down the execution of critical members.
            (6) These properties MUST be explicitly set on DllImport attributes of EACH import: 
               CharSet, PreserveSig, SetLastError, ExactSpelling.
            (7) CLR names MUST be used for types instead of C# ones, eg "Int32" not "int" and "Int64" not "long".
               This greately improves the understanding of the parameter sizes.
            (8) Sign of the types MUST be favored, eg "DWORD" is "UInt32" not "Int32".
            (9) Unsafe pointer types should be used for explicit and implicit pointers rather than IntPtr. 
               This way we outline the unsafety of the native calls, and also make it more clear for the 64bit transition.
               Eg "HANDLE" is "void*". If the rule forces you to mark some assembly as unsafe, it's an indication a managed utility
               incapsulating the call and the handle should be provided in one of the already-unsafe assemblies.
            (A) Same rules must apply to members of the structures.
            (B) All of the structures MUST have the [StructLayout(LayoutKind.Sequential)], [NoReorder] attributes, as appropriate.
            </remarks>
        </member>
        <member name="M:JetBrains.Interop.WinApi.UxThemeDll.CloseThemeData(System.Void*)">
            <summary>
            Closes the theme data handle.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.UxThemeDll.DrawThemeBackground(System.Void*,System.Void*,System.Int32,System.Int32,JetBrains.Interop.WinApi.RECT*,JetBrains.Interop.WinApi.RECT*)">
            <summary>
            Draws the border and fill defined by the visual style for the specified control part.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.UxThemeDll.IsAvailable">
            <summary>
            Checks whether the UxTheme DLL is available on this platform.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.UxThemeDll.OpenThemeData(System.Void*,System.String)">
            <summary>
            Opens the theme data for a window and its associated class.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.RECT">
            <summary>
            The RECT structure defines the coordinates of the upper-left and lower-right corners of a rectangle.
            By convention, the right and bottom edges of the rectangle are normally considered exclusive. In other words, the pixel whose coordinates are (right, bottom) lies immediately outside of the the rectangle. For example, when RECT is passed to the FillRect function, the rectangle is filled up to, but not including, the right column and bottom row of pixels. This structure is identical to the RECTL structure.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.RECT.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Interop.WinApi.TH32CS">
            <summary>
            The portions of the system to be included in the snapshot.
            See <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.CreateToolhelp32Snapshot(System.UInt32,System.UInt32)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.ScrollWindowFlags">
            <summary>
            Flags for the <see cref="!:Win32Declarations.ScrollWindowEx(IntPtr,int,int,ref RECT,ref RECT,IntPtr,IntPtr,ScrollWindowFlags)"/>, <see cref="!:Win32Declarations.ScrollWindowEx(IntPtr,int,int,ref RECT,ref RECT,IntPtr,ref RECT,UI.Interop.ScrollWindowFlags)"/> functions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ScrollWindowFlags.SW_ERASE">
            <summary>
            Erases the newly invalidated region by sending a WM_ERASEBKGND message to the window when specified with the SW_INVALIDATE flag.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ScrollWindowFlags.SW_INVALIDATE">
            <summary>
            Invalidates the region identified by the hrgnUpdate parameter after scrolling.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ScrollWindowFlags.SW_SCROLLCHILDREN">
            <summary>
            Scrolls all child windows that intersect the rectangle pointed to by the prcScroll parameter. The child windows are scrolled by the number of pixels specified by the dx and dy parameters. The system sends a WM_MOVE message to all child windows that intersect the prcScroll rectangle, even if they do not move.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.ScrollWindowFlags.SW_SMOOTHSCROLL">
            <summary>
            Windows 98/Me, Windows 2000/XP: Scrolls using smooth scrolling. Use the HIWORD portion of the flags parameter to indicate how much time the smooth-scrolling operation should take.      
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.SetWindowPosFlags">
            <summary>
            Flags for the <see cref="!:Win32Declarations.SetWindowPos"/> fucntion.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOSIZE">
            <summary>
            Retains the current size (ignores the cx and cy parameters).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOMOVE">
            <summary>
            Retains the current position (ignores X and Y parameters).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOZORDER">
            <summary>
            Retains the current Z order (ignores the hWndInsertAfter parameter).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOREDRAW">
            <summary>
            Does not redraw changes. If this flag is set, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of the window being moved. When this flag is set, the application must explicitly invalidate or redraw any parts of the window and parent window that need redrawing.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOACTIVATE">
            <summary>
            Does not activate the window. If this flag is not set, the window is activated and moved to the top of either the topmost or non-topmost group (depending on the setting of the hWndInsertAfter parameter).
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_FRAMECHANGED">
            <summary>
            Applies new frame styles set using the SetWindowLong function. Sends a WM_NCCALCSIZE message to the window, even if the window's size is not being changed. If this flag is not specified, WM_NCCALCSIZE is sent only when the window's size is being changed.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_SHOWWINDOW">
            <summary>
            Displays the window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_HIDEWINDOW">
            <summary>
            Hides the window.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOCOPYBITS">
            <summary>
            Discards the entire contents of the client area. If this flag is not specified, the valid contents of the client area are saved and copied back into the client area after the window is sized or repositioned.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOOWNERZORDER">
            <summary>
            Does not change the owner window's position in the Z order.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOSENDCHANGING">
            <summary>
            Prevents the window from receiving the WM_WINDOWPOSCHANGING message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_DEFERERASE">
            <summary>
            Prevents generation of the WM_SYNCPAINT message.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_ASYNCWINDOWPOS">
            <summary>
            If the calling thread and the thread that owns the window are attached to different input queues, the system posts the request to the thread that owns the window. This prevents the calling thread from blocking its execution while other threads process the request. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOREPOSITION">
            <summary>
            Same as the <see cref="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_NOOWNERZORDER"/> flag.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.SetWindowPosFlags.SWP_DRAWFRAME">
            <summary>
            Draws a frame (defined in the window's class description) around the window.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations">
            <summary>
            Possible raster operations for the <see cref="M:JetBrains.Interop.WinApi.Gdi32Dll.BitBlt(System.Void*,System.Int32,System.Int32,System.Int32,System.Int32,System.Void*,System.Int32,System.Int32,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.SRCCOPY">
            <summary>dest = source</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.SRCPAINT">
            <summary>dest = source OR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.SRCAND">
            <summary>dest = source AND dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.SRCINVERT">
            <summary>dest = source XOR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.SRCERASE">
            <summary>dest = source AND (NOT dest )</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.NOTSRCCOPY">
            <summary>dest = (NOT source)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.NOTSRCERASE">
            <summary>dest = (NOT src) AND (NOT dest)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.MERGECOPY">
            <summary>dest = (source AND pattern)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.MERGEPAINT">
            <summary>dest = (NOT source) OR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.PATCOPY">
            <summary>dest = pattern</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.PATPAINT">
            <summary>dest = DPSnoo</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.PATINVERT">
            <summary>dest = pattern XOR dest</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.DSTINVERT">
            <summary>dest = (NOT dest)</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.BLACKNESS">
            <summary>dest = BLACK</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.WHITENESS">
            <summary>dest = WHITE</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.NOMIRRORBITMAP">
            <summary>Do not Mirror the bitmap in this call</summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.RasterOperations.CAPTUREBLT">
            <summary>Include layered windows</summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags">
            <summary>
            Flags for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.UpdateLayeredWindow(System.Void*,System.Void*,JetBrains.Interop.WinApi.POINT*,JetBrains.Interop.WinApi.Declarations.Structures.SIZE*,System.Void*,JetBrains.Interop.WinApi.POINT*,System.UInt32,JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION*,System.UInt32)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_COLORKEY">
            <summary>
            Use crKey as the transparency color. (see <see cref="M:JetBrains.Interop.WinApi.User32Dll.UpdateLayeredWindow(System.Void*,System.Void*,JetBrains.Interop.WinApi.POINT*,JetBrains.Interop.WinApi.Declarations.Structures.SIZE*,System.Void*,JetBrains.Interop.WinApi.POINT*,System.UInt32,JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION*,System.UInt32)"/>)
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_ALPHA">
            <summary>
            Use pblend as the blend function. If the display mode is 256 colors or less, the effect of this value is the same as the effect of <see cref="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_OPAQUE"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Constants.UpdateLayeredWindowFlags.ULW_OPAQUE">
            <summary>
            Draw an opaque layered window. 
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Declarations.Structures.SIZE">
            <summary>
            The SIZE structure specifies the width and height of a rectangle.
            </summary>
            <remarks>The rectangle dimensions stored in this structure may correspond to viewport extents, window extents, text extents, bitmap dimensions, or the aspect-ratio filter for some extended functions. </remarks>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.cx">
            <summary>
            Specifies the rectangle's width. The units depend on which function uses this.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.cy">
            <summary>
            Specifies the rectangle's height. The units depend on which function uses this. 
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.Equals(JetBrains.Interop.WinApi.Declarations.Structures.SIZE)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Declarations.Structures.SIZE.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Interop.WinApi.StockCursors">
            <summary>
            Stock cursors enum for <see cref="!:LoadCursor(StockCursors)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_APPSTARTING">
            <summary>
            Standard arrow and small hourglass
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_ARROW">
            <summary>
            Standard arrow
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_CROSS">
            <summary>
            Crosshair
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_HAND">
            <summary>
            Windows 98/Me, Windows 2000/XP: Hand
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_HELP">
            <summary>
            Arrow and question mark
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_IBEAM">
            <summary>
            I-beam
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_ICON">
            <summary>
            Obsolete for applications marked version 4.0 or later.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_NO">
            <summary>
            Slashed circle
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZE">
            <summary>
            Obsolete for applications marked version 4.0 or later. Use IDC_SIZEALL.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZEALL">
            <summary>
            Four-pointed arrow pointing north, south, east, and west
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZENESW">
            <summary>
            /Double-pointed arrow pointing northeast and southwest
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZENS">
            <summary>
            Double-pointed arrow pointing north and south
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZENWSE">
            <summary>
            Double-pointed arrow pointing northwest and southeast
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_SIZEWE">
            <summary>
            Double-pointed arrow pointing west and east
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_UPARROW">
            <summary>
            Vertical arrow
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.StockCursors.IDC_WAIT">
            <summary>
            Hourglass
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations">
            <summary>
            Common Win32 Interop declarations
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.AC_SRC_OVER">
            <summary>
            When the BlendOp parameter is AC_SRC_OVER , the source bitmap is placed over the destination bitmap based on the alpha values of the source pixels. (<see cref="T:JetBrains.Interop.WinApi.Declarations.Structures.BLENDFUNCTION"/>)
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.AC_SRC_ALPHA">
            <summary>
            This flag is set when the bitmap has an Alpha channel (that is, per-pixel alpha). Note that the APIs use premultiplied alpha, which means that the red, green and blue channel values in the bitmap must be premultiplied with the alpha channel value. For example, if the alpha channel value is x, the red, green and blue channels must be multiplied by x and divided by 0xff prior to the call.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.DrawText(System.IntPtr,System.String,System.Int32,JetBrains.Interop.WinApi.RECT@,JetBrains.UI.Interop.DrawTextFormatFlags)">
            <summary>
            The DrawText function draws formatted text in the specified rectangle. It formats the text according to the specified method (expanding tabs, justifying characters, breaking lines, and so forth). 
            </summary>
            <returns>If the function succeeds, the return value is the height of the text in logical units. If DT_VCENTER or DT_BOTTOM is specified, the return value is the offset from lpRect->top to the bottom of the drawn text
            If the function fails, the return value is zero. 
            Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.GetUpdateRgn(System.IntPtr,System.IntPtr,System.Boolean)">
            <summary>
            The GetUpdateRgn function retrieves the update region of a window by copying it into the specified region. The coordinates of the update region are relative to the upper-left corner of the window (that is, they are client coordinates).
            </summary>
            <param name="hWnd">[in] Handle to the window with an update region that is to be retrieved.</param>
            <param name="hRgn">[in] Handle to the region to receive the update region.</param>
            <param name="bErase">[in] Specifies whether the window background should be erased and whether nonclient areas of child windows should be drawn. If this parameter is FALSE, no drawing is done.</param>
            <returns>The return value indicates the complexity of the resulting region; it can be one of the following values.</returns>
            <remarks>The BeginPaint function automatically validates the update region, so any call to GetUpdateRgn made immediately after the call to BeginPaint retrieves an empty update region.</remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.GetAncestor(System.IntPtr,JetBrains.Interop.WinApi.GetAncestorFlags)">
            <summary>
            The GetAncestor function retrieves the handle to the ancestor of the specified window. 
            </summary>
            <param name="hwnd">[in] Handle to the window whose ancestor is to be retrieved. If this parameter is the desktop window, the function returns <c>NULL</c>. </param>
            <param name="flags">[in] Specifies the ancestor to be retrieved. This parameter can be one of the following values.</param>
            <returns>The return value is the handle to the ancestor window.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.GetWindowRect(System.IntPtr)">
            <summary>
            Calls <c>WinAPI::GetWindowRect</c>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.AdjustWindowRectEx(JetBrains.Interop.WinApi.RECT@,System.UInt32,System.Int32,System.UInt32)">
            <summary>
            The AdjustWindowRectEx function calculates the required size of the window rectangle, based on the desired size of the client rectangle. The window rectangle can then be passed to the CreateWindowEx function to create a window whose client area is the desired size. 
            </summary>
            <param name="lpRect">[in, out] Pointer to a RECT structure that contains the coordinates of the top-left and bottom-right corners of the desired client area. When the function returns, the structure contains the coordinates of the top-left and bottom-right corners of the window to accommodate the desired client area. </param>
            <param name="dwStyle">[in] Specifies the window style of the window whose required size is to be calculated. Note that you cannot specify the WS_OVERLAPPED style. </param>
            <param name="bMenu">[in] Specifies whether the window has a menu.</param>
            <param name="dwExStyle">[in] Specifies the extended window style of the window whose required size is to be calculated. For more information, see CreateWindowEx.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.MoveWindow(System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            The MoveWindow function changes the position and dimensions of the specified window. For a top-level window, the position and dimensions are relative to the upper-left corner of the screen. For a child window, they are relative to the upper-left corner of the parent window's client area. 
            </summary>
            <param name="hWnd">[in] Handle to the window. </param>
            <param name="X">[in] Specifies the new position of the left side of the window. </param>
            <param name="Y">[in] Specifies the new position of the top of the window. </param>
            <param name="nWidth">[in] Specifies the new width of the window. </param>
            <param name="nHeight">[in] Specifies the new height of the window. </param>
            <param name="bRepaint">[in] Specifies whether the window is to be repainted. If this parameter is TRUE, the window receives a message. If the parameter is FALSE, no repainting of any kind occurs. This applies to the client area, the nonclient area (including the title bar and scroll bars), and any part of the parent window uncovered as a result of moving a child window. </param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.GetWindowText(System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
            The GetWindowText function copies the text of the specified window's title bar (if it has one) into a buffer. If the specified window is a control, the text of the control is copied. However, GetWindowText cannot retrieve the text of a control in another application.
            </summary>
            <param name="hWnd">[in] Handle to the window or control containing the text. </param>
            <param name="lpString">[out] Pointer to the buffer that will receive the text. If the string is as long or longer than the buffer, the string is truncated and terminated with a NULL character. </param>
            <param name="nMaxCount">[in] Specifies the maximum number of characters to copy to the buffer, including the NULL character. If the text exceeds this limit, it is truncated. </param>
            <returns>If the function succeeds, the return value is the length, in characters, of the copied string, not including the terminating NULL character. If the window has no title bar or text, if the title bar is empty, or if the window or control handle is invalid, the return value is zero. To get extended error information, call GetLastError. This function cannot retrieve the text of an edit control in another application.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.GetWindowTextLength(System.IntPtr)">
            <summary>
            The GetWindowTextLength function retrieves the length, in characters, of the specified window's title bar text (if the window has a title bar). If the specified window is a control, the function retrieves the length of the text within the control. However, GetWindowTextLength cannot retrieve the length of the text of an edit control in another application.
            </summary>
            <param name="hWnd">[in] Handle to the window or control.</param>
            <returns>If the function succeeds, the return value is the length, in characters, of the text. Under certain conditions, this value may actually be greater than the length of the text. For more information, see the following Remarks section. If the window has no text, the return value is zero. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.EndTask(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            The EndTask function is called to forcibly close a specified window. 
            </summary>
            <param name="hWnd">[in] Handle to the window to be closed. </param>
            <param name="fShutDown">[in] Ignored. Must be <c>FALSE</c>. </param>
            <param name="fForce">[in] A TRUE for this parameter will force the destruction of the window if an initial attempt fails to gently close the window using WM_CLOSE. With a FALSE for this parameter, only the close with WM_CLOSE is attempted.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is FALSE. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.ScrollWindowEx(System.IntPtr,System.Int32,System.Int32,JetBrains.Interop.WinApi.RECT@,JetBrains.Interop.WinApi.RECT@,System.IntPtr,JetBrains.Interop.WinApi.RECT@,JetBrains.Interop.WinApi.ScrollWindowFlags)">
            <summary>
            The ScrollWindowEx function scrolls the contents of the specified window's client area. 
            </summary>
            <param name="hWnd">[in] Handle to the window where the client area is to be scrolled. </param>
            <param name="dx">[in] Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.</param>
            <param name="dy">[in] Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up. </param>
            <param name="prcScroll">[in] Pointer to a RECT structure that specifies the portion of the client area to be scrolled. If this parameter is NULL, the entire client area is scrolled.</param>
            <param name="prcClip">[in] Pointer to a RECT structure that contains the coordinates of the clipping rectangle. Only device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted. This parameter may be NULL.</param>
            <param name="hrgnUpdate">[in] Handle to the region that is modified to hold the region invalidated by scrolling. This parameter may be NULL.</param>
            <param name="prcUpdate">[out] Pointer to a RECT structure that receives the boundaries of the rectangle invalidated by scrolling. This parameter may be NULL.</param>
            <param name="flags">[in] Specifies flags that control scrolling. This parameter can be one of the following values. </param>
            <returns>If the function succeeds, the return value is <see cref="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.SIMPLEREGION"/> (rectangular invalidated region), <see cref="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.COMPLEXREGION"/> (nonrectangular invalidated region; overlapping rectangles), or <see cref="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.NULLREGION"/> (no invalidated region). 
            If the function fails, the return value is <see cref="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.ERROR"/>. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.ScrollWindowEx(System.IntPtr,System.Int32,System.Int32,JetBrains.Interop.WinApi.RECT@,JetBrains.Interop.WinApi.RECT@,System.IntPtr,System.IntPtr,JetBrains.Interop.WinApi.ScrollWindowFlags)">
            <summary>
            The ScrollWindowEx function scrolls the contents of the specified window's client area. 
            </summary>
            <param name="hWnd">[in] Handle to the window where the client area is to be scrolled. </param>
            <param name="dx">[in] Specifies the amount, in device units, of horizontal scrolling. This parameter must be a negative value to scroll to the left.</param>
            <param name="dy">[in] Specifies the amount, in device units, of vertical scrolling. This parameter must be a negative value to scroll up. </param>
            <param name="prcScroll">[in] Pointer to a RECT structure that specifies the portion of the client area to be scrolled. If this parameter is NULL, the entire client area is scrolled.</param>
            <param name="prcClip">[in] Pointer to a RECT structure that contains the coordinates of the clipping rectangle. Only device bits within the clipping rectangle are affected. Bits scrolled from the outside of the rectangle to the inside are painted; bits scrolled from the inside of the rectangle to the outside are not painted. This parameter may be NULL.</param>
            <param name="hrgnUpdate">[in] Handle to the region that is modified to hold the region invalidated by scrolling. This parameter may be NULL.</param>
            <param name="prcUpdate">[out] Pointer to a RECT structure that receives the boundaries of the rectangle invalidated by scrolling. This parameter may be NULL.</param>
            <param name="flags">[in] Specifies flags that control scrolling. This parameter can be one of the following values. </param>
            <returns>If the function succeeds, the return value is <see cref="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.SIMPLEREGION"/> (rectangular invalidated region), <see cref="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.COMPLEXREGION"/> (nonrectangular invalidated region; overlapping rectangles), or <see cref="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.NULLREGION"/> (no invalidated region). 
            If the function fails, the return value is <see cref="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.ERROR"/>. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.FindWindowEx(System.IntPtr,System.IntPtr,System.String,System.String)">
            <summary>
            The FindWindowEx function retrieves a handle to a window whose class name and window name match the specified strings. The function searches child windows, beginning with the one following the specified child window. This function does not perform a case-sensitive search.
            If the lpszWindow parameter is not NULL, FindWindowEx calls the GetWindowText function to retrieve the window name for comparison. For a description of a potential problem that can arise, see the Remarks section of GetWindowText.
            </summary>
            <param name="hwndParent">[in] Handle to the parent window whose child windows are to be searched. If hwndParent is NULL, the function uses the desktop window as the parent window. The function searches among windows that are child windows of the desktop. Microsoft Windows 2000 and Windows XP: If hwndParent is HWND_MESSAGE, the function searches all message-only windows. </param>
            <param name="hwndChildAfter">[in] Handle to a child window. The search begins with the next child window in the Z order. The child window must be a direct child window of hwndParent, not just a descendant window. If hwndChildAfter is NULL, the search begins with the first child window of hwndParent. Note that if both hwndParent and hwndChildAfter are NULL, the function searches all top-level and message-only windows. </param>
            <param name="lpszClass">[in] Pointer to a null-terminated string that specifies the class name or a class atom created by a previous call to the RegisterClass or RegisterClassEx function. The atom must be placed in the low-order word of lpszClass; the high-order word must be zero.If lpszClass is a string, it specifies the window class name. The class name can be any name registered with RegisterClass or RegisterClassEx, or any of the predefined control-class names, or it can be MAKEINTATOM(0x800). In this latter case, 0x8000 is the atom for a menu class. For more information, see the Remarks section of this topic.</param>
            <param name="lpszWindow">[in] Pointer to a null-terminated string that specifies the window name (the window's title). If this parameter is NULL, all window names match. </param>
            <returns>If the function succeeds, the return value is a handle to the window that has the specified class and window names. If the function fails, the return value is NULL. To get extended error information, call GetLastError. </returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.CreateCompatibleDC(System.IntPtr)">
            <summary>
            The CreateCompatibleDC function creates a memory device context (DC) compatible with the specified device. 
            </summary>
            <param name="hdc">Handle to an existing DC. If this handle is NULL, the function creates a memory DC compatible with the application's current screen.</param>
            <returns>If the function succeeds, the return value is the handle to a memory DC. If the function fails, the return value is NULL.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.CreateCompatibleBitmap(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            The CreateCompatibleBitmap function creates a bitmap compatible with the device that is associated with the specified device context.
            </summary>
            <param name="hdc">handle to DC</param>
            <param name="nWidth">width of bitmap, in pixels</param>
            <param name="nHeight">height of bitmap, in pixels</param>
            <returns>If the function succeeds, the return value is a handle to the compatible bitmap (DDB). If the function fails, the return value is NULL.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.DeleteDC(System.IntPtr)">
            <summary>
            The DeleteDC function deletes the specified device context (DC).
            </summary>
            <param name="hDC">handle to DC</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.StrFormatByteSize64A(System.Int64,System.Byte[],System.UInt32)">
            <summary>
            Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
            </summary>
            <param name="nSize">Numeric value to be converted.</param>
            <param name="pBuffer">Pointer to a buffer to hold the converted number. Note: this function is bound to call the ANSI version.</param>
            <param name="nBufSize">Size of the buffer, in characters. Note: in our case, in bytes.</param>
            <returns>Returns the address of the converted string, or <see cref="F:System.IntPtr.Zero"/> if the conversion fails.</returns>
            <remarks>
            The following table illustrates how this function converts a numeric value into a text string.
            
            Numeric value -&gt; Text string 
            532 532 -&gt; bytes 
            1340 -&gt; 1.30KB 
            23506 -&gt; 22.9KB 
            2400016 -&gt; 2.29MB 
            2400000000 -&gt; 2.23GB 
            </remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.StrFormatByteSize64A(System.Int64,System.Text.StringBuilder,System.UInt32)">
            <summary>
            Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
            </summary>
            <param name="nSize">Numeric value to be converted.</param>
            <param name="pBuffer">Pointer to a buffer to hold the converted number. Note: this function is bound to call the ANSI version.</param>
            <param name="nBufSize">Size of the buffer, in characters. Note: in our case, in bytes.</param>
            <returns>Returns the address of the converted string, or <see cref="F:System.IntPtr.Zero"/> if the conversion fails.</returns>
            <remarks>
            The following table illustrates how this function converts a numeric value into a text string.
            
            Numeric value -&gt; Text string 
            532 532 -&gt; bytes 
            1340 -&gt; 1.30KB 
            23506 -&gt; 22.9KB 
            2400016 -&gt; 2.29MB 
            2400000000 -&gt; 2.23GB 
            </remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.StrFormatByteSize(System.Int64)">
            <summary>
            Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
            </summary>
            <param name="nSize">Numeric value to be converted.</param>
            <returns>Returns the size string.</returns>
            <remarks>
            The following table illustrates how this function converts a numeric value into a text string.
            
            Numeric value -> Text string 
            532 532 -> bytes 
            1340 -> 1.30KB 
            23506 -> 22.9KB 
            2400016 -> 2.29MB 
            2400000000 -> 2.23GB 
            </remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.SetWindowOrgEx(System.IntPtr,System.Int32,System.Int32,JetBrains.UI.Interop.POINTAPI@)">
            <summary>
            The SetWindowOrgEx function specifies which window point maps to the viewport origin (0,0).
            </summary>
            <param name="hdc">[in] Handle to the device context.</param>
            <param name="X">[in] Specifies the x-coordinate, in logical units, of the new window origin.</param>
            <param name="Y">[in] Specifies the y-coordinate, in logical units, of the new window origin.</param>
            <param name="lpPoint">[out] Pointer to a POINT structure that receives the previous origin of the window, in logical units. If lpPoint is NULL, this parameter is not used.</param>
            <returns>If the function succeeds, the return value is nonzero.
            If the function fails, the return value is zero.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.ExtSelectClipRgn(System.IntPtr,System.IntPtr,JetBrains.Interop.WinApi.CombineRgnStyles)">
            <summary>
            The ExtSelectClipRgn function combines the specified region with the current clipping region using the specified mode.
            </summary>
            <param name="hdc">[in] Handle to the device context. </param>
            <param name="hrgn">[in] Handle to the region to be selected. This handle can only be NULL when the RGN_COPY mode is specified.</param>
            <param name="fnMode">[in] Specifies the operation to be performed. It must be one of the following values. <see cref="T:JetBrains.Interop.WinApi.CombineRgnStyles"/></param>
            <returns>The return value specifies the new clipping region's complexity; it can be one of the following values. </returns>
            <remarks>If an error occurs when this function is called, the previous clipping region for the specified device context is not affected. The ExtSelectClipRgn function assumes that the coordinates for the specified region are specified in device units. Only a copy of the region identified by the hrgn parameter is used. The region itself can be reused after this call or it can be deleted. </remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.CreateRectRgn(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            The CreateRectRgn function creates a rectangular region. 
            </summary>
            <param name="nLeftRect">[in] Specifies the x-coordinate of the upper-left corner of the region in logical units. </param>
            <param name="nTopRect">[in] Specifies the y-coordinate of the upper-left corner of the region in logical units. </param>
            <param name="nRightRect">[in] Specifies the x-coordinate of the lower-right corner of the region in logical units.</param>
            <param name="nBottomRect">[in] Specifies the y-coordinate of the lower-right corner of the region in logical units.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.CombineRgn(System.IntPtr,System.IntPtr,System.IntPtr,JetBrains.Interop.WinApi.CombineRgnStyles)">
            <summary>
            The CombineRgn function combines two regions and stores the result in a third region. The two regions are combined according to the specified mode. 
            </summary>
            <param name="hrgnDest">[in] Handle to a new region with dimensions defined by combining two other regions. (This region must exist before CombineRgn is called.) </param>
            <param name="hrgnSrc1">[in] Handle to the first of two regions to be combined.</param>
            <param name="hrgnSrc2">[in] Handle to the second of two regions to be combined.</param>
            <param name="fnCombineMode">[in] Specifies a mode indicating how the two regions will be combined. This parameter can be one of the following values. </param>
            <returns>The return value specifies the type of the resulting region. It can be one of the following values. </returns>
            <remarks>The three regions need not be distinct. For example, the hrgnSrc1 parameter can equal the hrgnDest parameter. </remarks>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.SetWindowsHookEx(JetBrains.UI.Interop.HookType,JetBrains.UI.Interop.Win32Declarations.HookProc,System.IntPtr,System.Int32)">
            <summary>
            The SetWindowsHookEx function installs an application-defined hook procedure into a hook chain. You would install a hook procedure to monitor the system for certain types of events. These events are associated either with a specific thread or with all threads in the same desktop as the calling thread. 
            </summary>
            <returns>If the function succeeds, the return value is the handle to the hook procedure. 
            If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.LoadCursor(System.IntPtr,System.IntPtr)">
            <summary>
            The LoadCursor function loads the specified cursor resource from the executable (.EXE) file associated with an application instance.
            </summary>
            <param name="hInstance">[in] Handle to an instance of the module whose executable file contains the cursor to be loaded.</param>
            <param name="cursor">[in] Pointer to a null-terminated string that contains the name of the cursor resource to be loaded. Alternatively, this parameter can consist of the resource identifier in the low-order word and zero in the high-order word. The MAKEINTRESOURCE macro can also be used to create this value. To use one of the predefined cursors, the application must set the hInstance parameter to NULL and the lpCursorName parameter to one the following values:</param>
            <returns>If the function succeeds, the return value is the handle to the newly loaded cursor. If the function fails, the return value is NULL. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.LoadCursor(JetBrains.Interop.WinApi.StockCursors)">
            <summary>
            Loads the cursor by calling the <see cref="M:JetBrains.UI.Interop.Win32Declarations.LoadCursor(System.IntPtr,System.IntPtr)"/> WinAPI function.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.GetStockObject(JetBrains.UI.Interop.Win32Declarations.StockObject)">
            <summary>
            The GetStockObject function retrieves a handle to one of the stock pens, brushes, fonts, or palettes.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.DrawFrameControl(System.IntPtr,JetBrains.Interop.WinApi.RECT@,JetBrains.UI.Interop.Win32Declarations.FrameControlType,JetBrains.UI.Interop.Win32Declarations.FrameControlState)">
            <summary>
            The DrawFrameControl function draws a frame control of the specified type and style.
            </summary>
            <param name="hdc">[in] Handle to the device context of the window in which to draw the control.</param>
            <param name="bounds">[in] Pointer to a RECT structure that contains the logical coordinates of the bounding rectangle for frame control.</param>
            <param name="frameControlType">[in] Specifies the type of frame control to draw. This parameter can be one of the following values.</param>
            <param name="frameControlState">[in] Specifies the initial state of the frame control. If uType is DFC_BUTTON, uState can be one of the following values.</param>
            <returns>If the function succeeds, the return value is nonzero. If the function fails, the return value is zero. Windows NT/2000/XP: To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.SetDCBrushColor(System.IntPtr,System.Int32)">
            <summary>
            SetDCBrushColor function sets the current device context (DC) brush color to the specified color value. If the device cannot represent the specified color value, the color is set to the nearest physical color.
            </summary>
            <param name="hdc">[in] Handle to the DC.</param>
            <param name="colorref">[in] Specifies the new brush color.</param>
            <returns>If the function succeeds, the return value specifies the previous DC brush color as a COLORREF value. If the function fails, the return value is CLR_INVALID.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.VarR8FromStr(System.String,System.Int32,System.Int32,System.Double@)">
            <summary>
            This function converts variant data types to double from OLECHAR.
            Passing invalid (and under some circumstances NULL) pointers to this function causes an unexpected termination of the application.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuEx(System.IntPtr,JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags,System.Int32,System.Int32,System.IntPtr,System.IntPtr)">
            <summary>
            The TrackPopupMenuEx function displays a shortcut menu at the specified location and tracks the selection of items on the shortcut menu. The shortcut menu can appear anywhere on the screen.
            </summary>
            <param name="hmenu">[in] Handle to the shortcut menu to be displayed. This handle can be obtained by calling the CreatePopupMenu function to create a new shortcut menu or by calling the GetSubMenu function to retrieve a handle to a submenu associated with an existing menu item.</param>
            <param name="fuFlags">[in] Specifies function options. Use one of the following flags to specify how the function positions the shortcut menu horizontally.</param>
            <param name="x">[in] Horizontal location of the shortcut menu, in screen coordinates. </param>
            <param name="y">[in] Vertical location of the shortcut menu, in screen coordinates. </param>
            <param name="hwnd">[in] Handle to the window that owns the shortcut menu. This window receives all messages from the menu. The window does not receive a WM_COMMAND message from the menu until the function returns. If you specify TPM_NONOTIFY in the fuFlags parameter, the function does not send messages to the window identified by hwnd. However, you must still pass a window handle in hwnd. It can be any window handle from your application.</param>
            <param name="lptpm_PassNullHere">[in] Pointer to a TPMPARAMS structure that specifies an area of the screen the menu should not overlap. This parameter can be NULL. </param>
            <returns>If you specify TPM_RETURNCMD in the fuFlags parameter, the return value is the menu-item identifier of the item that the user selected. If the user cancels the menu without making a selection, or if an error occurs, then the return value is zero. If you do not specify TPM_RETURNCMD in the fuFlags parameter, the return value is nonzero if the function succeeds and zero if it fails. To get extended error information, call GetLastError.</returns>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.DwmExtendFrameIntoClientArea(System.IntPtr,JetBrains.UI.Interop.Win32Declarations.MARGINS)">
            <summary>
            Extends the window frame behind the client area.
            If Desktop Window Manager (DWM) composition is toggled, this function must be called again. Handle the WM_DWMCOMPOSITIONCHANGED message for composition change notification. 
            Negative margins are used to create the "sheet of glass" effect where the client area is rendered as a solid surface with no window border.
            </summary>
            <param name="hwnd">The handle to the window for which the frame is extended into the client area.</param>
            <param name="margins"><see cref="T:JetBrains.UI.Interop.Win32Declarations.MARGINS"/> that describes the margins to use when extending the frame into the client area.</param>
            <returns>Returns S_OK if successful, or an error value otherwise.</returns>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations.RegionResult">
            <summary>
            The return value specifies the new clipping region's complexity; it can be one of the following values. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.ERROR">
            <summary>
            An error occurred.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.NULLREGION">
            <summary>
            Region is empty.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.SIMPLEREGION">
            <summary>
            Region is a single rectangle.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.COMPLEXREGION">
            <summary>
            Region is more than one rectangle.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.RegionResult.RGN_ERROR">
            <summary>
            An error occurred.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations.HookProc">
            <summary>
            Hook delegate for the <see cref="M:JetBrains.UI.Interop.Win32Declarations.SetWindowsHookEx(JetBrains.UI.Interop.HookType,JetBrains.UI.Interop.Win32Declarations.HookProc,System.IntPtr,System.Int32)"/> function.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations.StatusBarStyles">
            <summary>
            Styles and flags for the status bar.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations.StatusBarBorders">
            <summary>
            Identifies the status bar borders for use with the messages like <see cref="F:JetBrains.Interop.WinApi.WindowsMessages.SB_GETBORDERS"/>.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StatusBarBorders.Horizontal">
            <summary>
            The horizontal border between the parts and the edges of the window.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StatusBarBorders.Vertical">
            <summary>
            The vertical border between the parts and the edges of the window.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StatusBarBorders.Separator">
            <summary>
            The spacing between the adjacent status bar parts.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations.StockObject">
            <summary>
            The stock GDI objects for the <see cref="M:JetBrains.UI.Interop.Win32Declarations.GetStockObject(JetBrains.UI.Interop.Win32Declarations.StockObject)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.BLACK_BRUSH">
            <summary>
            Black brush. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.DKGRAY_BRUSH">
            <summary>
            Dark gray brush. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.DC_BRUSH">
            <summary>
            Windows 2000/XP: Solid color brush. The default color is white. The color can be changed by using the SetDCBrushColor function. For more information= , see the Remarks section. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.GRAY_BRUSH">
            <summary>
            Gray brush. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.HOLLOW_BRUSH">
            <summary>
            Hollow brush (equivalent to NULL_BRUSH). 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.LTGRAY_BRUSH">
            <summary>
            Light gray brush. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.NULL_BRUSH">
            <summary>
            Null brush (equivalent to HOLLOW_BRUSH). 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.WHITE_BRUSH">
            <summary>
            White brush. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.BLACK_PEN">
            <summary>
            Black pen. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.DC_PEN">
            <summary>
            Windows 2000/XP: Solid pen color. The default color is white. The color can be changed by using the SetDCPenColor function. For more information= , see the Remarks section. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.WHITE_PEN">
            <summary>
            White pen. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.ANSI_FIXED_FONT">
            <summary>
            Windows fixed-pitch (monospace) system font. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.ANSI_VAR_FONT">
            <summary>
            Windows variable-pitch (proportional space) system font. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.DEVICE_DEFAULT_FONT">
            <summary>
            Windows NT/2000/XP: Device-dependent font. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.DEFAULT_GUI_FONT">
            <summary>
            Default font for user interface objects such as menus and dialog boxes. This is MS Sans Serif. Compare this with SYSTEM_FONT. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.OEM_FIXED_FONT">
            <summary>
            Original equipment manufacturer (OEM) dependent fixed-pitch (monospace) font. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.SYSTEM_FONT">
            <summary>
            System font. By default= , the system uses the system font to draw menus= , dialog box controls= , and text. Windows 95/98 and Windows NT: The system font is MS Sans Serif. Windows 2000/XP: The system font is Tahoma
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.SYSTEM_FIXED_FONT">
            <summary>
            Fixed-pitch (monospace) system font. This stock object is provided only for compatibility with 16-bit Windows versions earlier than 3.0.  
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.StockObject.DEFAULT_PALETTE">
            <summary>
            Default palette. This palette consists of the static colors in the system palette. 
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations.FrameControlType">
            <summary>
            Values for <see cref="M:JetBrains.UI.Interop.Win32Declarations.DrawFrameControl(System.IntPtr,JetBrains.Interop.WinApi.RECT@,JetBrains.UI.Interop.Win32Declarations.FrameControlType,JetBrains.UI.Interop.Win32Declarations.FrameControlState)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.FrameControlType.DFC_BUTTON">
            <summary>
            Standard button 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.FrameControlType.DFC_CAPTION">
            <summary>
            Title bar 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.FrameControlType.DFC_MENU">
            <summary>
            Menu bar 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.FrameControlType.DFC_POPUPMENU">
            <summary>
            Windows 98/Me, Windows 2000/XP: Popup menu item. 
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.FrameControlType.DFC_SCROLL">
            <summary>
            Scroll bar 
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations.FrameControlState">
            <summary>
            Values for <see cref="M:JetBrains.UI.Interop.Win32Declarations.DrawFrameControl(System.IntPtr,JetBrains.Interop.WinApi.RECT@,JetBrains.UI.Interop.Win32Declarations.FrameControlType,JetBrains.UI.Interop.Win32Declarations.FrameControlState)"/>.
            Incomplete.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.FrameControlState.DFCS_BUTTONPUSH">
            <summary>
            Push button
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags">
            <summary>
            Flags for the <see cref="M:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuEx(System.IntPtr,JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags,System.Int32,System.Int32,System.IntPtr,System.IntPtr)"/> function.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_CENTERALIGN">
            <summary>
            If this flag is set, the function centers the shortcut menu horizontally relative to the coordinate specified by the x parameter.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_LEFTALIGN">
            <summary>
            If this flag is set, the function positions the shortcut menu so that its left side is aligned with the coordinate specified by the x parameter.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_RIGHTALIGN">
            <summary>
            Positions the shortcut menu so that its right side is aligned with the coordinate specified by the x parameter.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_BOTTOMALIGN">
            <summary>
            If this flag is set, the function positions the shortcut menu so that its bottom side is aligned with the coordinate specified by the y parameter.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_TOPALIGN">
            <summary>
            If this flag is set, the function positions the shortcut menu so that its top side is aligned with the coordinate specified by the y parameter.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_VCENTERALIGN">
            <summary>
            If this flag is set, the function centers the shortcut menu vertically relative to the coordinate specified by the y parameter.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_NONOTIFY">
            <summary>
            If this flag is set, the function does not send notification messages when the user clicks on a menu item.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_RETURNCMD">
            <summary>
            If this flag is set, the function returns the menu item identifier of the user's selection in the return value.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_LEFTBUTTON">
            <summary>
            If this flag is set, the user can select menu items with only the left mouse button.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_RIGHTBUTTON">
            <summary>
            If this flag is set, the user can select menu items with both the left and right mouse buttons.   /// </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_HORNEGANIMATION">
            <summary>
            Animates the menu from right to left.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_HORPOSANIMATION">
            <summary>
            Animates the menu from left to right.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_NOANIMATION">
            <summary>
            Displays menu without animation.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_VERNEGANIMATION">
            <summary>
            Animates the menu from bottom to top.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_VERPOSANIMATION">
            <summary>
            Animates the menu from top to bottom.
             For any animation to occur, the SystemParametersInfo function must set SPI_SETMENUANIMATION. Also, all the TPM_*ANIMATION flags, except TPM_NOANIMATION, are ignored if menu fade animation is on, See the SPI_GETMENUFADE flag in SystemParametersInfo.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_HORIZONTAL">
            <summary>
            If the menu cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to accommodate the requested horizontal alignment before the requested vertical alignment.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.TrackPopupMenuExFlags.TPM_VERTICAL">
            <summary>
            If the menu cannot be shown at the specified location without overlapping the excluded rectangle, the system tries to accommodate the requested vertical alignment before the requested horizontal alignment. 
            The excluded rectangle is a portion of the screen that the menu should not overlap; it is specified by lptpm. 
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations.WmSizeFlags">
            <summary>
            Flags that go along with the WM_SIZE message in its wParam.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.WmSizeFlags.SIZE_RESTORED">
            <summary>
            The window has been resized, but neither the <see cref="F:JetBrains.UI.Interop.Win32Declarations.WmSizeFlags.SIZE_MINIMIZED"/> nor <see cref="F:JetBrains.UI.Interop.Win32Declarations.WmSizeFlags.SIZE_MAXIMIZED"/> value applies.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.WmSizeFlags.SIZE_MINIMIZED">
            <summary>
            The window has been minimized.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.WmSizeFlags.SIZE_MAXIMIZED">
            <summary>
            The window has been maximized.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.WmSizeFlags.SIZE_MAXSHOW">
            <summary>
            Message is sent to all pop-up windows when some other window has been restored to its former size.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Interop.Win32Declarations.WmSizeFlags.SIZE_MAXHIDE">
            <summary>
            Message is sent to all pop-up windows when some other window is maximized.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Interop.Win32Declarations.MARGINS">
            <summary>
            Returned by the GetThemeMargins function to define the margins of windows that have visual styles applied.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.MARGINS.#ctor">
            <summary>
            Sets no margin.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.Win32Declarations.MARGINS.#ctor(System.Int32)">
            <summary>
            Sets all margins to the same value.
            </summary>
        </member>
        <member name="P:JetBrains.UI.Interop.Win32Declarations.MARGINS.WholeSurface">
            <summary>
            Sets the margins so that they cover the whole surface.
            </summary>
        </member>
        <member name="P:JetBrains.UI.Interop.Win32Declarations.MARGINS.Null">
            <summary>
            Sets the margins so that they cover none of the window inner surface.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.POINTAPI.#ctor(System.IntPtr)">
            <summary>
            Creates a new point, unpacking its signed coordinates from an LPARAM, using the <see cref="M:JetBrains.Interop.WinApi.Macros.GET_X_LPARAM(System.IntPtr)"/> and <see cref="M:JetBrains.Interop.WinApi.Macros.GET_Y_LPARAM(System.IntPtr)"/> functions.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Interop.POINTAPI.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.UI.Interop.HookType">
            <summary>
            Windows hook types for <see cref="M:JetBrains.UI.Interop.Win32Declarations.SetWindowsHookEx(JetBrains.UI.Interop.HookType,JetBrains.UI.Interop.Win32Declarations.HookProc,System.IntPtr,System.Int32)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WindowsMessages">
            <summary>
            Windows message constants.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowsMessages.WM_PRINT">
            <summary>
            The WM_PRINT message is sent to a window to request that it draw itself in the specified device context, most commonly in a printer device context.
            wParam is hdc, lParam is drawing options (PRF_…)
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.WindowLongPtrIndex">
            <summary>
            Index constants for the <see cref="M:JetBrains.Interop.WinApi.User32Dll.GetWindowLongPtrW(System.Void*,System.Int32)"/> and <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetWindowLongPtrW(System.Void*,System.Int32,System.IntPtr)"/> functions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWL_EXSTYLE">
            <summary>
            Sets a new extended window style. For more information, see CreateWindowEx. 
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWL_STYLE">
            <summary>
            Sets a new window style.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_WNDPROC">
            <summary>
            Sets a new address for the window procedure. 
            Same as GWL_WNDPROC that is for non-“ptr” versions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_HINSTANCE">
            <summary>
            Sets a new application instance handle.
            Same as GWL_HINSTANCE that is for non-“ptr” versions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_HWNDPARENT">
            <summary>
            Do not call <see cref="M:JetBrains.Interop.WinApi.User32Dll.SetWindowLongPtrW(System.Void*,System.Int32,System.IntPtr)"/> with the <see cref="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_HWNDPARENT"/> index to change the parent of a child window. Instead, use the SetParent function.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_ID">
            <summary>
            Sets a new identifier of the window.
            Same as GWL_ID that is for non-“ptr” versions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.GWLP_USERDATA">
            <summary>
            Sets the user data associated with the window. This data is intended for use by the application that created the window. Its value is initially zero.
            Same as GWL_USERDATA that is for non-“ptr” versions.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.DWLP_DLGPROC">
            <summary>
            Sets the new pointer to the dialog box procedure.
            Valid for dialog boxes only.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.DWLP_MSGRESULT">
            <summary>
            Sets the return value of a message processed in the dialog box procedure.
            Valid for dialog boxes only.
            </summary>
        </member>
        <member name="F:JetBrains.Interop.WinApi.WindowLongPtrIndex.DWLP_USER">
            <summary>
            Sets new extra information that is private to the application, such as handles or pointers.      
            Valid for dialog boxes only.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Win32InteropException">
            <summary>
            Denotes an exception that occurs during the interop calls.
            </summary>
        </member>
        <member name="T:JetBrains.Interop.WinApi.Wrappers.Win32Window">
            <summary>
            Implements the <see cref="T:System.Windows.Forms.IWin32Window"/> interface by just wrapping the handle.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Wrappers.Win32Window.#ctor(System.IntPtr)">
            <summary>
            Wraps a native window handle.
            Can be <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Interop.WinApi.Wrappers.Win32Window.#ctor(System.Void*)">
            <summary>
            Wraps a native window handle.
            Can be <c>Null</c>.
            </summary>
        </member>
        <member name="P:JetBrains.Interop.WinApi.Wrappers.Win32Window.Handle">
            <summary>
            Gets the handle to the window represented by the implementer.
            </summary>
            
            <returns>
            A handle to the window represented by the implementer.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
    </members>
</doc>
